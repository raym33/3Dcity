<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C1 English Metropolis MEGA</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: #000; overflow: hidden; }
        #game-container { width: 100vw; height: 100vh; position: relative; }
        canvas { display: block; }
        .hidden { display: none !important; }
        
        .ui-panel {
            position: absolute;
            background: linear-gradient(180deg, #000080 0%, #000050 100%);
            border: 3px outset #4040ff;
            color: #ffff00;
            padding: 8px 12px;
            font-size: 14px;
        }
        
        #title-bar {
            top: 0; left: 0; right: 0;
            background: linear-gradient(180deg, #0000aa 0%, #000066 100%);
            border-bottom: 3px outset #4040ff;
            padding: 6px 15px;
            display: flex; justify-content: space-between;
            font-size: 15px; z-index: 100;
        }
        
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.85);
            border-radius: 1px;
        }
        #crosshair::before { width: 16px; height: 2px; top: -1px; left: -8px; }
        #crosshair::after { width: 2px; height: 16px; left: -1px; top: -8px; }
        
        /* WAYPOINT ARROW */
        #waypoint {
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid #ffff00;
            filter: drop-shadow(0 0 10px #ffff00);
            transform-origin: center 80px;
            z-index: 45;
            pointer-events: none;
            transition: transform 0.1s;
        }
        #waypoint-dist {
            position: absolute;
            top: calc(50% + 100px); left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #ffff00;
            padding: 5px 12px;
            font-size: 12px;
            border: 1px solid #ffff00;
            z-index: 45;
            pointer-events: none;
        }
        
        #minimap-panel { top: 45px; left: 10px; z-index: 100; border-radius: 5px; padding: 5px; }
        #minimap { width: 150px; height: 150px; background: #001a00; border: 2px inset #004400; position: relative; overflow: hidden; }
        .map-player { position: absolute; width: 6px; height: 6px; background: #00ff00; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 8px #00ff00; }
        .map-marker { position: absolute; width: 4px; height: 4px; background: #ff0; border-radius: 50%; transform: translate(-50%, -50%); }
        .map-marker.bus { background: #0f0; }
        
        #voice-panel { top: 45px; left: 175px; z-index: 100; padding: 4px 8px; }
        #voice-select { background: #003; color: #0ff; border: 1px solid #066; padding: 2px; font-size: 11px; }
        
        #papers-panel { top: 45px; right: 10px; z-index: 100; }
        
        #mission-panel { top: 90px; right: 10px; z-index: 100; max-height: 200px; overflow-y: auto; width: 220px; }
        .mission-item { padding: 6px 8px; margin: 3px 0; background: rgba(0,50,0,0.8); border: 1px solid #060; cursor: pointer; font-size: 11px; }
        .mission-item:hover { background: rgba(0,80,0,0.9); }
        .mission-item.active { border-color: #ff0; background: rgba(80,80,0,0.8); }
        .mission-dist { float: right; color: #aaa; font-size: 10px; }
        
        #location-bar {
            bottom: 0; left: 0; right: 0;
            background: linear-gradient(180deg, #000066 0%, #000033 100%);
            border-top: 3px outset #4040ff;
            padding: 8px 15px;
            display: flex; justify-content: space-between;
            z-index: 100;
        }
        
        #interact-prompt {
            bottom: 55px; left: 50%; transform: translateX(-50%);
            text-align: center; z-index: 100;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        #interact-prompt .icon { font-size: 24px; }
        
        #instructions {
            position: absolute; inset: 0;
            background: linear-gradient(180deg, #000020 0%, #000060 50%, #000020 100%);
            display: flex; align-items: center; justify-content: center;
            z-index: 200;
        }
        #instructions-box {
            background: linear-gradient(180deg, #0000cc 0%, #000066 100%);
            border: 4px outset #6060ff;
            padding: 25px 35px; max-width: 850px; text-align: center;
            color: #ffffff;
        }
        #instructions-box h1 { font-size: 28px; color: #ffff00; text-shadow: 3px 3px #000; margin-bottom: 5px; }
        .key { background: #333; color: #fff; padding: 3px 8px; border: 2px outset #666; margin: 0 2px; font-size: 11px; }
        .feature-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin: 12px 0; text-align: left; font-size: 10px; }
        .feature-grid div { background: rgba(0,0,0,0.3); padding: 4px 7px; color: #aaffaa; }
        .start-btn {
            margin-top: 15px; padding: 14px 45px;
            font-family: 'Courier New', monospace; font-size: 18px; font-weight: bold;
            background: linear-gradient(180deg, #00aa00 0%, #006600 100%);
            border: 3px outset #00ff00; color: #ffffff; cursor: pointer;
        }
        .start-btn:hover { background: linear-gradient(180deg, #00cc00 0%, #008800 100%); }
        
        /* INTERIOR & BUS UI */
        .ui-btn {
            padding: 10px 18px;
            font-family: 'Courier New', monospace; font-size: 13px; font-weight: bold;
            border: 3px outset; cursor: pointer; color: #fff;
        }
        .ui-btn.talk { background: linear-gradient(180deg, #0066aa 0%, #003366 100%); border-color: #00aaff; }
        .ui-btn.paper { background: linear-gradient(180deg, #aa6600 0%, #663300 100%); border-color: #ffaa00; }
        .ui-btn.exit { background: linear-gradient(180deg, #aa0000 0%, #660000 100%); border-color: #ff0000; }
        .ui-btn.play { background: linear-gradient(180deg, #006600 0%, #003300 100%); border-color: #00ff00; }
        .ui-btn.bus { background: linear-gradient(180deg, #006666 0%, #003333 100%); border-color: #00ffff; }
        
        #interior-ui, #arcade-ui, #bus-ui {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            z-index: 100; display: flex; gap: 10px;
        }
        
        /* BUS ROUTES PANEL */
        #bus-routes {
            position: absolute; inset: 0;
            background: rgba(0,30,30,0.95);
            display: flex; align-items: center; justify-content: center;
            z-index: 160;
        }
        #bus-routes-box {
            background: linear-gradient(180deg, #003333 0%, #001a1a 100%);
            border: 3px solid #00ffff;
            padding: 25px; min-width: 400px; max-width: 500px;
        }
        #bus-routes-box h2 { color: #00ffff; text-align: center; margin-bottom: 15px; }
        .bus-stop { padding: 12px; margin: 8px 0; background: rgba(0,80,80,0.5); border: 1px solid #066; cursor: pointer; }
        .bus-stop:hover { background: rgba(0,120,120,0.6); border-color: #0ff; }
        .bus-stop-name { color: #0ff; font-weight: bold; }
        .bus-stop-desc { color: #aaa; font-size: 11px; margin-top: 3px; }
        
        /* DIALOGUE */
        #dialogue-overlay {
            position: absolute; inset: 0;
            background: rgba(0,0,30,0.95);
            display: flex; align-items: center; justify-content: center;
            z-index: 150;
        }
        #dialogue-box {
            background: linear-gradient(180deg, #000080 0%, #000040 100%);
            border: 4px outset #4040ff;
            width: 90%; max-width: 700px;
            max-height: 85vh; overflow-y: auto;
        }
        .dlg-header {
            background: linear-gradient(90deg, #000066 0%, #330066 100%);
            padding: 12px 15px;
            border-bottom: 2px solid #6060ff;
            display: flex; justify-content: space-between; align-items: center;
        }
        .dlg-header .speaker { color: #00ffff; font-size: 16px; }
        .dlg-close { background: #cc0000; border: 2px outset #ff0000; color: #fff; padding: 5px 12px; cursor: pointer; }
        .dlg-grammar { background: rgba(100,0,100,0.5); padding: 8px 15px; color: #ff88ff; border-bottom: 1px solid #660066; }
        .dlg-content { padding: 15px; }
        .dlg-speech { background: rgba(0,0,80,0.6); border: 2px inset #4040aa; padding: 12px; margin-bottom: 10px; color: #ffffff; line-height: 1.5; }
        .dlg-listen { margin-top: 8px; padding: 5px 12px; font-family: 'Courier New', monospace; background: #006600; border: 2px outset #00aa00; color: #fff; cursor: pointer; }
        .dlg-option {
            display: block; width: 100%;
            text-align: left; padding: 10px 12px;
            margin: 5px 0;
            font-family: 'Courier New', monospace; font-size: 13px;
            background: linear-gradient(180deg, #333366 0%, #222244 100%);
            border: 2px outset #6666aa;
            color: #ffffff; cursor: pointer;
        }
        .dlg-option:hover { background: linear-gradient(180deg, #4444aa 0%, #333366 100%); }
        .dlg-option .letter { color: #ffff00; margin-right: 8px; }
        .dlg-feedback { margin-top: 10px; padding: 10px; border: 2px inset; }
        .dlg-feedback.correct { background: rgba(0,80,0,0.8); border-color: #00aa00; color: #00ff00; }
        .dlg-feedback.incorrect { background: rgba(80,0,0,0.8); border-color: #aa0000; color: #ff6666; }
        .dlg-vocab { margin-top: 12px; padding: 10px; background: rgba(50,50,0,0.5); border: 1px solid #666600; }
        .dlg-vocab h4 { color: #ffff00; margin-bottom: 6px; }
        .vocab-word { display: inline-block; background: #333300; border: 1px solid #666600; padding: 3px 8px; margin: 2px; color: #ffff00; cursor: pointer; font-size: 12px; }
        .vocab-word:hover { background: #555500; }
        
        /* PAPER VIEWER */
        #paper-viewer {
            position: absolute; inset: 0;
            background: rgba(20,10,0,0.95);
            display: flex; align-items: center; justify-content: center;
            z-index: 155;
        }
        #paper-box {
            background: #f5f0e0;
            border: 3px solid #8b4513;
            padding: 25px 30px;
            max-width: 650px;
            color: #333;
            font-family: Georgia, serif;
            box-shadow: 5px 5px 20px rgba(0,0,0,0.5);
        }
        #paper-box .paper-type { color: #8b4513; font-size: 12px; margin-bottom: 5px; }
        #paper-box h2 { color: #222; margin-bottom: 12px; font-size: 20px; }
        #paper-content { line-height: 1.6; font-size: 14px; }
        #paper-content .grammar-note { background: #fffacd; padding: 8px; margin: 10px 0; border-left: 3px solid #daa520; font-style: italic; }
        #paper-close { margin-top: 15px; padding: 8px 20px; font-family: 'Courier New', monospace; background: #8b4513; border: none; color: #fff; cursor: pointer; }
        
        /* ARCADE & PACMAN */
        #pacman-overlay {
            position: absolute; inset: 0;
            background: #0a0a0a;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 170;
        }
        #pacman-overlay::before {
            content: '';
            position: absolute; inset: 0;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,255,0.03) 2px, rgba(0,255,255,0.03) 4px);
            pointer-events: none;
        }
        #pacman-title {
            font-size: 36px; color: #ffff00;
            text-shadow: 0 0 20px #ffff00, 0 0 40px #ff8800;
            letter-spacing: 6px; margin-bottom: 10px;
        }
        #pacman-hud { display: flex; gap: 30px; margin: 10px 0; color: #fff; font-size: 14px; }
        #pacman-hud span { color: #0ff; }
        #pacman-canvas { border: 3px solid #00ffff; box-shadow: 0 0 20px rgba(0,255,255,0.5); }
        #pacman-controls { margin-top: 15px; display: flex; gap: 15px; }
        #pacman-message { color: #ff0; font-size: 20px; margin-top: 10px; min-height: 30px; }
        #pacman-instructions { color: #888; font-size: 11px; margin-top: 8px; }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- INSTRUCTIONS -->
        <div id="instructions">
            <div id="instructions-box">
                <h1>üèôÔ∏è C1 ENGLISH METROPOLIS</h1>
                <p style="color:#ff88ff;margin:8px 0">The Ultimate English Learning City - MEGA Edition</p>
                <p style="margin:10px 0;font-size:12px">
                    <span class="key">W/S</span> Forward/Back
                    <span class="key">A/D</span> Strafe
                    <span class="key">‚Üê/‚Üí</span> Turn
                    <span class="key">DRAG</span> Look
                    <span class="key">SHIFT</span> Run
                    <span class="key">SPACE</span> Interact
                    <span class="key">E</span> Papers
                </p>
                <div class="feature-grid">
                    <div>üè¢ 25+ Skyscrapers</div>
                    <div>‚õ™ Gothic Cathedral</div>
                    <div>üì∫ Animated LED Signs</div>
                    <div>üöå Bus Transit System</div>
                    <div>üéØ Mission Waypoints</div>
                    <div>üõí 12+ Shop Interiors</div>
                    <div>üë• 100+ NPCs</div>
                    <div>üó£Ô∏è 40+ Dialogues</div>
                    <div>üì∞ Grammar Papers</div>
                    <div>üéß Voice Synthesis</div>
                    <div>üå≥ 6 City Parks</div>
                    <div>üïπÔ∏è Playable Pac-Man</div>
                    <div>üöó Traffic System</div>
                    <div>üö∂ 80+ Pedestrians</div>
                    <div>üèÜ Score System</div>
                    <div>üìç Interactive Minimap</div>
                </div>
                <button class="start-btn" id="start-btn">‚ñ∫ ENTER METROPOLIS</button>
            </div>
        </div>
        
        <!-- HUD -->
        <div id="title-bar" class="hidden">
            <span style="color:#00ffff">üèôÔ∏è C1 METROPOLIS MEGA</span>
            <span>Score: <span id="score" style="color:#00ff00">0</span> | Missions: <span id="missions" style="color:#ffff00">0/40</span></span>
        </div>
        
        <div id="crosshair" class="hidden"></div>
        <div id="waypoint" class="hidden"></div>
        <div id="waypoint-dist" class="hidden">üìç 0m</div>
        
        <div id="minimap-panel" class="ui-panel hidden">
            <div style="color:#00ffff;font-size:10px;margin-bottom:3px">üìç MAP</div>
            <div id="minimap"><div class="map-player" id="map-player"></div></div>
        </div>
        
        <div id="voice-panel" class="ui-panel hidden">
            üîä <select id="voice-select"><option>Loading...</option></select>
        </div>
        
        <div id="papers-panel" class="ui-panel hidden">üì∞ Papers: <span id="papers-count">0</span></div>
        
        <div id="mission-panel" class="ui-panel hidden">
            <div style="color:#0ff;margin-bottom:5px;font-size:11px">üéØ MISSIONS (click to track)</div>
            <div id="mission-list"></div>
        </div>
        
        <div id="location-bar" class="hidden">
            <span style="color:#00ffff">üìç <span id="loc-name">City Streets</span></span>
            <span style="color:#aaaaaa;font-size:11px" id="loc-hint">üñ±Ô∏è Drag to look | ‚Üê/‚Üí to turn | WASD to move</span>
        </div>
        
        <div id="interact-prompt" class="ui-panel hidden">
            <div class="icon" id="prompt-icon">üö™</div>
            <div style="color:#fff;margin:3px 0" id="prompt-name">Building</div>
            <div style="color:#00ff00;font-size:11px" id="prompt-action">Press SPACE</div>
        </div>
        
        <!-- INTERIOR UI -->
        <div id="interior-ui" class="hidden">
            <button class="ui-btn talk" id="btn-talk">üí¨ TALK</button>
            <button class="ui-btn paper" id="btn-paper">üì∞ PAPER</button>
            <button class="ui-btn exit" id="btn-exit">üö™ EXIT</button>
        </div>
        
        <!-- ARCADE UI -->
        <div id="arcade-ui" class="hidden">
            <button class="ui-btn play" id="btn-play-pacman">üïπÔ∏è PLAY PAC-MAN</button>
            <button class="ui-btn exit" id="btn-exit-arcade">üö™ EXIT ARCADE</button>
        </div>
        
        <!-- BUS UI -->
        <div id="bus-ui" class="hidden">
            <button class="ui-btn bus" id="btn-bus-routes">üó∫Ô∏è VIEW ROUTES</button>
            <button class="ui-btn exit" id="btn-exit-bus">üö™ EXIT BUS</button>
        </div>
        
        <!-- BUS ROUTES -->
        <div id="bus-routes" class="hidden">
            <div id="bus-routes-box">
                <h2>üöå BUS ROUTES - Select Destination</h2>
                <div id="bus-stops-list"></div>
                <button class="ui-btn exit" style="width:100%;margin-top:15px" id="btn-close-routes">CLOSE</button>
            </div>
        </div>
        
        <!-- DIALOGUE -->
        <div id="dialogue-overlay" class="hidden">
            <div id="dialogue-box">
                <div class="dlg-header">
                    <span class="speaker"><span id="dlg-icon">üë§</span> <span id="dlg-name">NPC</span></span>
                    <button class="dlg-close" id="dlg-close">‚úï</button>
                </div>
                <div class="dlg-grammar">üìñ Grammar Focus: <span id="dlg-grammar">Third Conditional</span></div>
                <div class="dlg-content">
                    <div class="dlg-speech">
                        <div id="dlg-text">"..."</div>
                        <button class="dlg-listen" id="dlg-listen">üîä Listen</button>
                    </div>
                    <div id="dlg-options"></div>
                    <div id="dlg-feedback"></div>
                    <div class="dlg-vocab">
                        <h4>üìö Key Vocabulary (click to hear):</h4>
                        <div id="dlg-vocab-list"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- PAPER VIEWER -->
        <div id="paper-viewer" class="hidden">
            <div id="paper-box">
                <div id="paper-content"></div>
                <button id="paper-close">‚úï Close</button>
            </div>
        </div>
        
        <!-- PAC-MAN OVERLAY -->
        <div id="pacman-overlay" class="hidden">
            <div id="pacman-title">PAC-MAN</div>
            <div id="pacman-hud">
                <div>SCORE: <span id="pac-score">0</span></div>
                <div>HIGH: <span id="pac-high">0</span></div>
                <div>LIVES: <span id="pac-lives">3</span></div>
            </div>
            <canvas id="pacman-canvas" width="456" height="504"></canvas>
            <div id="pacman-controls">
                <button class="ui-btn play" id="pac-start">‚ñ∂ START</button>
                <button class="ui-btn exit" id="pac-quit">‚úï QUIT</button>
            </div>
            <div id="pacman-message"></div>
            <div id="pacman-instructions">Use ‚Üë ‚Üì ‚Üê ‚Üí or WASD to move | ESC to quit</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
(function() {
    'use strict';
    
    // ============ PAPERS DATA - SPECIFIC TO EACH ESTABLISHMENT ============
    var papers = {
        // CLOTHING STORE
        clothing1: { type: "Fashion Magazine", title: "Haute Couture Trends 2024", content: "<p>Remarkable as this season's collections may <strong>appear</strong>, they represent a paradigm shift in sustainable fashion.</p><p class='grammar-note'>üìù Fronted 'as' Clauses: Adjective + as + subject + may + verb</p><p>Had designers embraced eco-conscious materials earlier, the industry's environmental footprint <strong>would have been</strong> significantly reduced.</p>", location: "clothing" },
        clothing2: { type: "Style Guide", title: "Bespoke Tailoring Excellence", content: "<p>Not only does bespoke tailoring <strong>ensure</strong> impeccable fit, but it also reflects individual personality.</p><p class='grammar-note'>üìù Correlative Conjunctions: Not only... but also</p><p>Were clients to invest in quality craftsmanship, their wardrobes <strong>would transcend</strong> fleeting trends.</p>", location: "clothing" },
        
        // ELECTRONICS STORE
        electronics1: { type: "Tech Review", title: "Quantum Computing Breakthrough", content: "<p>Seldom <strong>have we witnessed</strong> such revolutionary advancement in processing capabilities.</p><p class='grammar-note'>üìù Negative Inversion: Seldom + auxiliary + subject + verb</p><p>Were quantum supremacy to be achieved commercially, cryptographic systems <strong>would require</strong> complete restructuring.</p>", location: "electronics" },
        electronics2: { type: "Consumer Report", title: "AI Integration in Devices", content: "<p>Had manufacturers prioritized user privacy earlier, consumer trust <strong>would not have eroded</strong> so significantly.</p><p class='grammar-note'>üìù Third Conditional: Had + past participle, would have + past participle</p><p>Under no circumstances <strong>should consumers</strong> overlook data security specifications.</p>", location: "electronics" },
        
        // PHARMACY
        pharmacy1: { type: "Medical Bulletin", title: "Pharmaceutical Innovations", content: "<p>It is imperative that patients <strong>adhere</strong> strictly to prescribed dosages.</p><p class='grammar-note'>üìù Subjunctive Mood: It is imperative that + subject + base verb</p><p>Were contraindications to be disclosed promptly, adverse reactions <strong>could be mitigated</strong>.</p>", location: "pharmacy" },
        pharmacy2: { type: "Health Advisory", title: "Preventive Healthcare Protocols", content: "<p>Only through consistent preventive measures <strong>can individuals</strong> optimize their long-term wellness.</p><p class='grammar-note'>üìù Inversion with Only: Only + adverbial + auxiliary + subject + verb</p><p>Remarkable as these therapeutic advances may seem, clinical trials remain essential.</p>", location: "pharmacy" },
        
        // RESTAURANT
        restaurant1: { type: "Culinary Review", title: "Gastronomic Excellence Redefined", content: "<p>Exquisite as the degustation menu may <strong>appear</strong>, it represents years of culinary refinement.</p><p class='grammar-note'>üìù Fronted 'as' Clauses: Adjective + as + subject + may + verb</p><p>Had the sommelier not recommended this vintage, the pairing <strong>would have been</strong> suboptimal.</p>", location: "restaurant" },
        restaurant2: { type: "Food & Wine", title: "Farm-to-Table Philosophy", content: "<p>Not only does locally-sourced produce <strong>enhance</strong> flavor profiles, but it also supports sustainable agriculture.</p><p class='grammar-note'>üìù Correlative Conjunctions</p><p>Were chefs to embrace seasonal ingredients exclusively, culinary creativity <strong>would flourish</strong>.</p>", location: "restaurant" },
        
        // BANK
        bank1: { type: "Financial Times", title: "Portfolio Diversification Strategies", content: "<p>Had investors diversified their portfolios earlier, market volatility <strong>would not have impacted</strong> returns so severely.</p><p class='grammar-note'>üìù Third Conditional</p><p>Under no circumstances <strong>should fiduciary responsibilities</strong> be compromised for short-term gains.</p>", location: "bank" },
        bank2: { type: "Investment Report", title: "Cryptocurrency Regulations", content: "<p>Seldom <strong>has the financial sector</strong> experienced such regulatory uncertainty.</p><p class='grammar-note'>üìù Negative Inversion: Seldom + auxiliary + subject + verb</p><p>Were comprehensive frameworks to be established, institutional adoption <strong>would accelerate</strong>.</p>", location: "bank" },
        
        // CAFE
        cafe1: { type: "Barista Monthly", title: "Single-Origin Excellence", content: "<p>Subtle as the flavor notes may <strong>seem</strong>, they reflect terroir and processing methods.</p><p class='grammar-note'>üìù Fronted 'as' Clauses</p><p>Had roasters not perfected their extraction techniques, such nuanced profiles <strong>would remain</strong> unattainable.</p>", location: "cafe" },
        cafe2: { type: "Coffee Quarterly", title: "Specialty Brewing Methods", content: "<p>Only through meticulous temperature control <strong>can baristas</strong> achieve optimal extraction.</p><p class='grammar-note'>üìù Inversion with Only</p><p>Were water quality to be compromised, even premium beans <strong>would yield</strong> mediocre results.</p>", location: "cafe" },
        
        // BOOKSTORE
        bookstore1: { type: "Literary Review", title: "Contemporary Fiction Analysis", content: "<p>Complex as the narrative structure may <strong>appear</strong>, it illuminates profound philosophical themes.</p><p class='grammar-note'>üìù Fronted 'as' Clauses</p><p>Not only has this author challenged genre conventions, but she has also redefined literary discourse.</p>", location: "bookstore" },
        bookstore2: { type: "Publishers Weekly", title: "The Renaissance of Print", content: "<p>Remarkable as digital publishing's growth has <strong>been</strong>, physical books maintain their cultural significance.</p><p class='grammar-note'>üìù Fronted 'as' Clauses</p><p>Had e-readers entirely supplanted print, the tactile reading experience <strong>would have been</strong> lost.</p>", location: "bookstore" },
        
        // GYM
        gym1: { type: "Fitness Journal", title: "Periodization Principles", content: "<p>Were athletes to implement progressive overload systematically, hypertrophy <strong>would be</strong> optimized.</p><p class='grammar-note'>üìù Formal Conditionals: Were + subject + to + infinitive</p><p>Only through consistent compound movements <strong>can individuals</strong> achieve functional strength.</p>", location: "gym" },
        gym2: { type: "Sports Science", title: "Recovery Optimization", content: "<p>Had the athlete prioritized recovery protocols, overtraining syndrome <strong>could have been</strong> prevented.</p><p class='grammar-note'>üìù Third Conditional</p><p>Under no circumstances <strong>should proper nutrition</strong> be neglected during intensive training phases.</p>", location: "gym" },
        
        // HOTEL
        hotel1: { type: "Hospitality Review", title: "Luxury Accommodation Standards", content: "<p>Were guests to experience our bespoke concierge services, their expectations <strong>would be</strong> exceeded.</p><p class='grammar-note'>üìù Formal Conditionals</p><p>Not only do premium amenities enhance comfort, but they also create memorable experiences.</p>", location: "hotel" },
        hotel2: { type: "Travel Elite", title: "Boutique Hotel Renaissance", content: "<p>Distinctive as each property may <strong>appear</strong>, they share commitment to personalized service.</p><p class='grammar-note'>üìù Fronted 'as' Clauses</p><p>Had standardization dominated hospitality, authentic cultural immersion <strong>would have been</strong> sacrificed.</p>", location: "hotel" },
        
        // GALLERY
        gallery1: { type: "Art Quarterly", title: "Contemporary Installation Art", content: "<p>Provocative as this installation may <strong>seem</strong>, it addresses profound socio-political themes.</p><p class='grammar-note'>üìù Fronted 'as' Clauses</p><p>Seldom <strong>has conceptual art</strong> generated such discourse among critics.</p>", location: "gallery" },
        gallery2: { type: "Curator's Notes", title: "The Evolution of Abstract Expression", content: "<p>Had collectors recognized this movement's significance earlier, these works <strong>would have commanded</strong> higher valuations.</p><p class='grammar-note'>üìù Third Conditional</p><p>Only through sustained contemplation <strong>can viewers</strong> appreciate the artist's intention.</p>", location: "gallery" },
        
        // SUPERMARKET
        supermarket1: { type: "Consumer Guide", title: "Organic Certification Standards", content: "<p>It is essential that consumers <strong>verify</strong> certification authenticity before purchasing.</p><p class='grammar-note'>üìù Subjunctive Mood: It is essential that + subject + base verb</p><p>Were labeling regulations to be strengthened, misleading claims <strong>would diminish</strong>.</p>", location: "supermarket" },
        supermarket2: { type: "Retail Analysis", title: "Supply Chain Sustainability", content: "<p>Not only does local sourcing <strong>reduce</strong> carbon footprint, but it also supports community economies.</p><p class='grammar-note'>üìù Correlative Conjunctions</p><p>Had retailers prioritized ethical procurement, consumer trust <strong>would have increased</strong> substantially.</p>", location: "supermarket" },
        
        // STADIUM
        stadium1: { type: "Sports Illustrated", title: "Championship Tactical Analysis", content: "<p>Had the defense maintained their positioning, the counterattack <strong>would have been</strong> neutralized.</p><p class='grammar-note'>üìù Third Conditional</p><p>Seldom <strong>has a match</strong> demonstrated such tactical sophistication.</p>", location: "stadium" },
        stadium2: { type: "Athletic Weekly", title: "Sports Psychology Insights", content: "<p>Were athletes to master visualization techniques, performance anxiety <strong>would be</strong> significantly reduced.</p><p class='grammar-note'>üìù Formal Conditionals</p><p>Only under pressure <strong>do champions</strong> truly reveal their character.</p>", location: "stadium" },
        
        // DISCO/NIGHTCLUB
        disco1: { type: "Electronic Beats", title: "The Evolution of EDM", content: "<p>Not only has electronic music <strong>transcended</strong> cultural barriers, but it has also unified global audiences.</p><p class='grammar-note'>üìù Correlative Conjunctions</p><p>Had synthesizer technology not evolved, contemporary soundscapes <strong>would be</strong> unimaginable.</p>", location: "disco" },
        disco2: { type: "DJ Magazine", title: "Sound System Engineering", content: "<p>Critical as acoustic calibration may <strong>seem</strong>, it determines the entire auditory experience.</p><p class='grammar-note'>üìù Fronted 'as' Clauses</p><p>Were frequency response to be compromised, even premium tracks <strong>would sound</strong> mediocre.</p>", location: "disco" },
        
        // CATHEDRAL
        cathedral1: { type: "Architectural Digest", title: "Gothic Vaulting Mastery", content: "<p>Magnificent as these flying buttresses may <strong>appear</strong>, their engineering precision is equally remarkable.</p><p class='grammar-note'>üìù Fronted 'as' Clauses</p><p>Had medieval craftsmen not pioneered these techniques, such vertical grandeur <strong>would have been</strong> impossible.</p>", location: "cathedral" },
        cathedral2: { type: "Heritage Quarterly", title: "Stained Glass Conservation", content: "<p>It is imperative that restoration <strong>preserve</strong> original artistic intent.</p><p class='grammar-note'>üìù Subjunctive Mood</p><p>Under no circumstances <strong>should modern materials</strong> compromise historical authenticity.</p>", location: "cathedral" },
        
        // SKY TOWER
        skytower1: { type: "Panorama Magazine", title: "Elevated Dining Experience", content: "<p>Were you to combine panoramic vistas with our degustation menu, the evening <strong>would be</strong> unforgettable.</p><p class='grammar-note'>üìù Formal Conditionals</p><p>Spectacular as the cityscape may appear, the culinary artistry matches it.</p>", location: "skyTower" },
        skytower2: { type: "Gourmet Heights", title: "Sommelier's Selection", content: "<p>Had this vintage not been cellared properly, its complexity <strong>would have been</strong> compromised.</p><p class='grammar-note'>üìù Third Conditional</p><p>Only at this elevation <strong>can diners</strong> appreciate the city's true magnificence.</p>", location: "skyTower" }
    };
    
    // Get paper by location
    function getPaperForLocation(locationKey) {
        var locationPapers = Object.keys(papers).filter(function(key) {
            return papers[key].location === locationKey;
        });
        if (locationPapers.length > 0) {
            return papers[locationPapers[Math.floor(Math.random() * locationPapers.length)]];
        }
        // Fallback to random paper
        var allKeys = Object.keys(papers);
        return papers[allKeys[Math.floor(Math.random() * allKeys.length)]];
    }
    
    // ============ MISSIONS DATA ============
    var missions = {
        // OUTDOOR NPCs
        doctor: { type: 'outdoor', topic: "Medicine", icon: "üë®‚Äç‚öïÔ∏è", npcName: "Dr. Williams", dialogues: [{ npc: "Had the diagnostic imaging been conducted earlier, the prognosis might have been considerably more favorable.", options: [{ text: "Had early intervention been prioritized, treatment outcomes would have been optimized.", correct: true }, { text: "Early tests are important.", correct: false }], grammar: "Third Conditional" }], vocabulary: ["diagnostic", "prognosis", "intervention", "therapeutic"] },
        architect: { type: 'outdoor', topic: "Architecture", icon: "üë∑", npcName: "Ms. Peterson", dialogues: [{ npc: "Were we to incorporate sustainable materials, the carbon footprint would be reduced substantially.", options: [{ text: "Were biophilic design principles to be integrated, occupant wellbeing would be enhanced.", correct: true }, { text: "Green buildings are nice.", correct: false }], grammar: "Formal Conditionals" }], vocabulary: ["sustainable", "biophilic", "facade", "structural"] },
        professor: { type: 'outdoor', topic: "Academia", icon: "üéì", npcName: "Prof. Richardson", dialogues: [{ npc: "Not only does interdisciplinary research yield innovative insights, but it also challenges paradigms.", options: [{ text: "Not only has collaborative scholarship advanced the field, but it has also fostered discourse.", correct: true }, { text: "Research is important.", correct: false }], grammar: "Correlative Conjunctions" }], vocabulary: ["interdisciplinary", "paradigm", "scholarly", "discourse"] },
        lawyer: { type: 'outdoor', topic: "Law", icon: "‚öñÔ∏è", npcName: "Attorney Morrison", dialogues: [{ npc: "Seldom have I encountered such flagrant disregard for contractual obligations.", options: [{ text: "Rarely does one witness such blatant breach of fiduciary duty.", correct: true }, { text: "They broke the contract.", correct: false }], grammar: "Negative Inversion" }], vocabulary: ["contractual", "fiduciary", "litigation", "precedent"] },
        diplomat: { type: 'outdoor', topic: "Diplomacy", icon: "üåê", npcName: "Ambassador Chen", dialogues: [{ npc: "It is imperative that all parties exercise restraint during negotiations.", options: [{ text: "It is essential that diplomatic channels remain open regardless of tensions.", correct: true }, { text: "Everyone should stay calm.", correct: false }], grammar: "Subjunctive Mood" }], vocabulary: ["diplomatic", "restraint", "bilateral", "multilateral"] },
        journalist: { type: 'outdoor', topic: "Media", icon: "üì∞", npcName: "Sarah Mitchell", dialogues: [{ npc: "Under no circumstances should confidential sources be compromised.", options: [{ text: "At no point should journalistic integrity be sacrificed for sensationalism.", correct: true }, { text: "Protect your sources.", correct: false }], grammar: "Negative Inversion" }], vocabulary: ["investigative", "transparency", "accountability", "editorial"] },
        
        // PARK NPCs
        parkJogger: { type: 'park', topic: "Fitness", icon: "üèÉ", npcName: "Coach Martinez", dialogues: [{ npc: "Had I maintained a consistent training regimen, I wouldn't have hit the wall.", options: [{ text: "Had you incorporated adequate periodization, your performance would have been optimized.", correct: true }, { text: "Running is hard.", correct: false }], grammar: "Third Conditional" }], vocabulary: ["regimen", "periodization", "endurance", "hydration"] },
        parkArtist: { type: 'park', topic: "Art", icon: "üé®", npcName: "Elena Rodriguez", dialogues: [{ npc: "Unconventional as my artistic approach may be, it resonates with collectors.", options: [{ text: "Abstract as your compositions appear, they convey profound meaning.", correct: true }, { text: "Your art is nice.", correct: false }], grammar: "Fronted 'as' Clauses" }], vocabulary: ["composition", "symbolism", "aesthetic", "abstract"] },
        parkReader: { type: 'park', topic: "Literature", icon: "üìö", npcName: "Prof. Bennett", dialogues: [{ npc: "Remarkable as the protagonist's journey may seem, it reflects universal themes.", options: [{ text: "Complex as the narrative structure is, it illuminates philosophical perspectives.", correct: true }, { text: "The book is well written.", correct: false }], grammar: "Fronted 'as' Clauses" }], vocabulary: ["protagonist", "narrative", "philosophical", "allegory"] },
        parkYogi: { type: 'park', topic: "Wellness", icon: "üßò", npcName: "Maya Patel", dialogues: [{ npc: "Only through consistent practice can one achieve mindfulness.", options: [{ text: "Only by releasing attachment to outcomes can practitioners experience clarity.", correct: true }, { text: "Yoga is relaxing.", correct: false }], grammar: "Inversion with Only" }], vocabulary: ["mindfulness", "meditation", "alignment", "breathwork"] },
        parkPhotographer: { type: 'park', topic: "Photography", icon: "üì∑", npcName: "David Kim", dialogues: [{ npc: "Had the lighting been more favorable, I would have captured the perfect shot.", options: [{ text: "Had you adjusted your aperture settings, the depth of field would have been optimal.", correct: true }, { text: "The light was bad.", correct: false }], grammar: "Third Conditional" }], vocabulary: ["aperture", "composition", "exposure", "focal"] },
        parkBotanist: { type: 'park', topic: "Botany", icon: "üåø", npcName: "Dr. Green", dialogues: [{ npc: "Fascinating as these specimens may be, their ecological significance extends beyond aesthetics.", options: [{ text: "Remarkable as the biodiversity is, the interconnected relationships warrant study.", correct: true }, { text: "Plants are interesting.", correct: false }], grammar: "Fronted 'as' Clauses" }], vocabulary: ["specimens", "ecological", "biodiversity", "symbiotic"] },
        
        // BUILDING INTERIORS
        clothingShop: { type: 'interior', buildingType: 'clothing', topic: "Fashion", icon: "üëî", buildingName: "ELITE FASHION", npcName: "Emma Collins", dialogues: [{ npc: "Exquisite as this haute couture may be, does it align with your aesthetic?", options: [{ text: "Tempting as the pieces are, I'm seeking something more understated.", correct: true }, { text: "The clothes look expensive.", correct: false }], grammar: "Fronted 'as' Clauses" }], vocabulary: ["haute couture", "aesthetic", "bespoke", "silhouette"] },
        electronicsShop: { type: 'interior', buildingType: 'electronics', topic: "Technology", icon: "üì±", buildingName: "TECH NEXUS", npcName: "James Chen", dialogues: [{ npc: "Only by comparing specifications can you make an informed decision.", options: [{ text: "Only after evaluating total cost of ownership will I commit to this investment.", correct: true }, { text: "I need to compare prices.", correct: false }], grammar: "Inversion with Only" }], vocabulary: ["specifications", "bandwidth", "compatibility", "optimization"] },
        pharmacy: { type: 'interior', buildingType: 'pharmacy', topic: "Healthcare", icon: "üíä", buildingName: "WELLNESS PHARMACY", npcName: "Dr. Patel", dialogues: [{ npc: "It is essential that patients strictly adhere to the prescribed dosage.", options: [{ text: "It is imperative that any contraindications be disclosed before treatment.", correct: true }, { text: "I'll follow the instructions.", correct: false }], grammar: "Subjunctive Mood" }], vocabulary: ["dosage", "contraindication", "therapeutic", "pharmaceutical"] },
        restaurant: { type: 'interior', buildingType: 'restaurant', topic: "Gastronomy", icon: "üçΩÔ∏è", buildingName: "LA MAISON GOURMET", npcName: "Chef Dubois", dialogues: [{ npc: "Delectable as the tasting menu may appear, do you have dietary restrictions?", options: [{ text: "Enticing as the offerings are, I must ascertain whether you accommodate my requirements.", correct: true }, { text: "The menu looks good.", correct: false }], grammar: "Fronted 'as' Clauses" }], vocabulary: ["gastronomic", "sommelier", "palate", "degustation"] },
        bank: { type: 'interior', buildingType: 'bank', topic: "Finance", icon: "üè¶", buildingName: "PREMIER BANK", npcName: "Victoria Sterling", dialogues: [{ npc: "Had you diversified earlier, you would have mitigated market fluctuations.", options: [{ text: "Had I reallocated assets according to portfolio theory, returns would have been superior.", correct: true }, { text: "I should have invested differently.", correct: false }], grammar: "Third Conditional" }], vocabulary: ["portfolio", "diversification", "fiduciary", "liquidity"] },
        cafe: { type: 'interior', buildingType: 'cafe', topic: "Coffee", icon: "‚òï", buildingName: "ARTISAN ROASTERS", npcName: "Tom Baker", dialogues: [{ npc: "Intriguing as our single-origin pour-over may be, what are your preferences?", options: [{ text: "Appealing as the fruity acidity sounds, I gravitate toward full-bodied profiles.", correct: true }, { text: "I like strong coffee.", correct: false }], grammar: "Fronted 'as' Clauses" }], vocabulary: ["extraction", "roast profile", "acidity", "terroir"] },
        bookstore: { type: 'interior', buildingType: 'bookstore', topic: "Literature", icon: "üìñ", buildingName: "LITERARY HAVEN", npcName: "Margaret Price", dialogues: [{ npc: "Not only does this author challenge narrative structures, but she also redefines genre.", options: [{ text: "Not only has her prose garnered acclaim, but it has also resonated with audiences.", correct: true }, { text: "She's a good writer.", correct: false }], grammar: "Correlative Conjunctions" }], vocabulary: ["narrative", "prose", "genre", "contemporary"] },
        gym: { type: 'interior', buildingType: 'gym', topic: "Fitness", icon: "üèãÔ∏è", buildingName: "IRON TEMPLE", npcName: "Coach Marcus", dialogues: [{ npc: "Were you to follow this periodized program, your strength gains would be substantial.", options: [{ text: "Were I to incorporate progressive overload systematically, hypertrophy would be optimized.", correct: true }, { text: "I want to get stronger.", correct: false }], grammar: "Formal Conditionals" }], vocabulary: ["periodization", "hypertrophy", "progressive overload", "compound"] },
        hotel: { type: 'interior', buildingType: 'hotel', topic: "Hospitality", icon: "üè®", buildingName: "GRAND METROPOLITAN", npcName: "Mr. Hughes", dialogues: [{ npc: "Were you to upgrade to our executive suite, you would enjoy exclusive amenities.", options: [{ text: "Were I to extend my reservation, what preferential arrangements could be accommodated?", correct: true }, { text: "What does the upgrade include?", correct: false }], grammar: "Formal Conditionals" }], vocabulary: ["amenities", "concierge", "complimentary", "bespoke"] },
        gallery: { type: 'interior', buildingType: 'gallery', topic: "Art", icon: "üñºÔ∏è", buildingName: "MODERN ART GALLERY", npcName: "Curator Laurent", dialogues: [{ npc: "Provocative as this installation may appear, it addresses socio-political themes.", options: [{ text: "Challenging as the conceptual framework is, it effectively deconstructs paradigms.", correct: true }, { text: "The art is interesting.", correct: false }], grammar: "Fronted 'as' Clauses" }], vocabulary: ["installation", "conceptual", "paradigm", "contemporary"] },
        supermarket: { type: 'interior', buildingType: 'supermarket', topic: "Retail", icon: "üõí", buildingName: "FRESH MART", npcName: "Manager Davis", dialogues: [{ npc: "It is recommended that customers verify expiration dates before purchasing.", options: [{ text: "It is advisable that shoppers compare unit prices to maximize value.", correct: true }, { text: "Check the dates.", correct: false }], grammar: "Subjunctive Mood" }], vocabulary: ["expiration", "inventory", "procurement", "wholesale"] },
        arcade: { type: 'arcade', topic: "Gaming", icon: "üïπÔ∏è", buildingName: "RETRO ARCADE", npcName: "Alex Gamer", dialogues: [{ npc: "Had classic arcade games not existed, modern gaming would never have evolved.", options: [{ text: "Had developers not pioneered pixel art, contemporary aesthetics would be different.", correct: true }, { text: "Old games are fun.", correct: false }], grammar: "Third Conditional" }], vocabulary: ["retro", "pixel", "joystick", "highscore"] },
        
        // SKYSCRAPER NPCs
        ceo: { type: 'skyscraper', topic: "Corporate", icon: "üëî", buildingName: "APEX TOWER", npcName: "Mr. Harrison III", dialogues: [{ npc: "Had we anticipated the market volatility, we would have hedged our positions more aggressively.", options: [{ text: "Had I been privy to the quarterly projections, I would have advocated for diversification.", correct: true }, { text: "Markets are unpredictable.", correct: false }], grammar: "Third Conditional" }], vocabulary: ["volatility", "hedge", "portfolio", "fiduciary"] },
        aiResearcher: { type: 'skyscraper', topic: "AI Research", icon: "ü§ñ", buildingName: "AI RESEARCH CENTER", npcName: "Dr. Yamamoto", dialogues: [{ npc: "Were transformer architectures not developed, natural language processing would remain limited.", options: [{ text: "Were attention mechanisms not to revolutionize sequence modeling, AI capabilities would be inconceivable.", correct: true }, { text: "AI has improved a lot.", correct: false }], grammar: "Formal Conditionals" }], vocabulary: ["transformer", "neural", "parameters", "inference"] },
        
        // CATHEDRAL
        curator: { type: 'cathedral', topic: "Art History", icon: "‚õ™", buildingName: "GOTHIC CATHEDRAL", npcName: "Father Thomas", dialogues: [{ npc: "Magnificent as this architecture may appear, its spiritual significance transcends aesthetics.", options: [{ text: "Awe-inspiring as the Gothic vaulting is, the symbolism warrants contemplation.", correct: true }, { text: "The building is beautiful.", correct: false }], grammar: "Fronted 'as' Clauses" }], vocabulary: ["Gothic", "vaulting", "transcendent", "ecclesiastical"] },
        
        // NEW LARGE VENUES
        stadium: { type: 'interior', buildingType: 'stadium', topic: "Sports", icon: "üèüÔ∏è", buildingName: "METROPOLIS STADIUM", npcName: "Coach Rodriguez", dialogues: [{ npc: "Had our striker not sustained that injury, we would have secured the championship.", options: [{ text: "Had the defense maintained their positioning, the opposition's counterattack would have been neutralized.", correct: true }, { text: "The team played badly.", correct: false }], grammar: "Third Conditional" }], vocabulary: ["championship", "counterattack", "formation", "tactics"] },
        disco: { type: 'interior', buildingType: 'disco', topic: "Nightlife", icon: "ü™©", buildingName: "NEON NIGHTS CLUB", npcName: "DJ Electra", dialogues: [{ npc: "Not only does electronic music unite diverse audiences, but it also transcends cultural barriers.", options: [{ text: "Not only has the genre evolved exponentially, but it has also influenced mainstream culture.", correct: true }, { text: "The music is loud.", correct: false }], grammar: "Correlative Conjunctions" }], vocabulary: ["electronic", "synthesizer", "rhythm", "ambient"] },
        bigRestaurant: { type: 'interior', buildingType: 'restaurant', topic: "Fine Dining", icon: "üç∑", buildingName: "THE GRAND PAVILION", npcName: "Ma√Ætre D'Antoine", dialogues: [{ npc: "Were you to experience our degustation menu, your palate would be thoroughly impressed.", options: [{ text: "Were the sommelier to recommend a pairing, the gastronomic experience would be elevated.", correct: true }, { text: "The food looks nice.", correct: false }], grammar: "Formal Conditionals" }], vocabulary: ["degustation", "sommelier", "gastronomic", "amuse-bouche"] },
        cathedral2: { type: 'interior', buildingType: 'cathedral', topic: "History", icon: "üïç", buildingName: "ST. MICHAEL'S BASILICA", npcName: "Monsignor Pietro", dialogues: [{ npc: "Under no circumstances should the historical significance of these relics be underestimated.", options: [{ text: "At no point should we overlook the architectural achievements of medieval craftsmen.", correct: true }, { text: "The church is old.", correct: false }], grammar: "Negative Inversion" }], vocabulary: ["basilica", "medieval", "ecclesiastical", "consecrated"] },
        techHub: { type: 'interior', buildingType: 'electronics', topic: "Innovation", icon: "üí°", buildingName: "INNOVATION HUB", npcName: "Dr. Tesla Wright", dialogues: [{ npc: "Seldom has technological advancement progressed at such an unprecedented pace.", options: [{ text: "Rarely do we witness such convergence of artificial intelligence and quantum computing.", correct: true }, { text: "Technology is changing fast.", correct: false }], grammar: "Negative Inversion" }], vocabulary: ["quantum", "convergence", "exponential", "paradigm"] },
        
        // SKY TOWER
        skyTower: { type: 'skyTower', buildingType: 'restaurant', topic: "Panoramic Dining", icon: "üóº", buildingName: "SKY TOWER RESTAURANT", npcName: "Sommelier Laurent", dialogues: [{ npc: "Were you to sample our vintage Bordeaux while admiring the cityscape, the experience would be unforgettable.", options: [{ text: "Were I to combine the panoramic vistas with your renowned degustation menu, it would constitute a truly transcendent evening.", correct: true }, { text: "The view is nice.", correct: false }], grammar: "Formal Conditionals" }], vocabulary: ["panoramic", "vintage", "sommelier", "transcendent"] }
    };
    
    // ============ BUS STOPS ============
    var busStops = [
        { name: "Downtown Central", x: 0, z: 50, desc: "City center, main plaza" },
        { name: "Business District", x: 350, z: -350, desc: "Skyscrapers, corporate offices" },
        { name: "Tech Quarter", x: -350, z: -350, desc: "Innovation hub, startups" },
        { name: "Cultural Center", x: -450, z: 450, desc: "Cathedral, museums" },
        { name: "Shopping District", x: 350, z: 350, desc: "Retail stores, restaurants" },
        { name: "Park West", x: -150, z: 50, desc: "Green spaces, recreation" },
        { name: "University Area", x: 0, z: -450, desc: "Education, libraries" },
        { name: "Stadium District", x: 550, z: 0, desc: "Sports arena, entertainment" },
        { name: "Nightlife Zone", x: -550, z: -150, desc: "Clubs, bars, restaurants" },
        { name: "Grand Plaza", x: 0, z: 550, desc: "The Grand Pavilion, luxury dining" },
        { name: "Sky Tower", x: 0, z: -480, desc: "Panoramic restaurant, observation deck" }
    ];
    
    // ============ GAME STATE ============
    var scene, camera, renderer;
    var playerPos = { x: 0, y: 1.7, z: 100 };
    var playerVel = { x: 0, y: 0, z: 0 };
    var playerRot = { x: 0, y: 0 };
    var targetRot = { x: 0, y: 0 };
    var smoothRot = { x: 0, y: 0 };
    var keys = {};
    var npcs = [], parkNPCs = [], buildingEntrances = [], skyscraperEntrances = [];
    var pedestrians = [], cars = [], buses = [], policeCars = [], airplanes = [];
    var currentNPC = null, currentBuilding = null, currentBus = null;
    var currentMission = null, dialogueIndex = 0, score = 0, completedMissions = [];
    var collectedPapers = 0;
    var selectedVoice = null;
    var isInside = false, isInArcade = false, isOnBus = false, isInElevator = false, currentInteriorKey = null;
    var interiorScene = null, interiorCamera = null;
    var interiorPlayerPos = { x: 0, z: 4 };
    var interiorRot = { x: 0, y: 0 };
    var interiorTargetRot = { x: 0, y: 0 };
    var activeMission = null;
    var gameStarted = false;
    var groundFriction = 0.91, acceleration = 0.035, maxWalkSpeed = 0.4, maxRunSpeed = 0.85, rotationSmoothing = 0.09;
    var headBob = { phase: 0, intensity: 0 };
    var CITY_SIZE = 500;
    var animTime = 0;
    var elevatorY = 0, elevatorTargetY = 0, elevatorBuilding = null;
    var skyTower = null, skyTowerEntrance = null;
    
    // ============ VOICE SYSTEM ============
    function initVoices() {
        var sel = document.getElementById('voice-select');
        function populate() {
            var voices = speechSynthesis.getVoices().filter(function(v) { return v.lang.startsWith('en'); });
            sel.innerHTML = '';
            voices.slice(0, 10).forEach(function(v, i) {
                var opt = document.createElement('option');
                opt.value = i;
                opt.textContent = v.name.substring(0, 16);
                sel.appendChild(opt);
            });
            if (voices.length > 0) selectedVoice = voices[0];
        }
        speechSynthesis.onvoiceschanged = populate;
        populate();
        sel.onchange = function() {
            var voices = speechSynthesis.getVoices().filter(function(v) { return v.lang.startsWith('en'); });
            selectedVoice = voices[parseInt(sel.value)] || null;
        };
    }
    
    function speak(text) {
        speechSynthesis.cancel();
        var u = new SpeechSynthesisUtterance(text);
        u.rate = 0.85;
        if (selectedVoice) u.voice = selectedVoice;
        speechSynthesis.speak(u);
    }
    
    // ============ UI FUNCTIONS ============
    function startGame() {
        document.getElementById('instructions').classList.add('hidden');
        ['title-bar', 'minimap-panel', 'voice-panel', 'papers-panel', 'mission-panel', 'location-bar', 'crosshair', 'waypoint', 'waypoint-dist'].forEach(function(id) {
            document.getElementById(id).classList.remove('hidden');
        });
        initGame();
        gameStarted = true;
        updateMissionList();
    }
    
    function updateHUD() {
        document.getElementById('score').textContent = score;
        document.getElementById('missions').textContent = completedMissions.length + '/' + Object.keys(missions).length;
        document.getElementById('papers-count').textContent = collectedPapers;
    }
    
    function updateMinimap() {
        if (isInside || isOnBus || isInArcade) return;
        var scale = 150 / (CITY_SIZE * 2.2);
        var p = document.getElementById('map-player');
        p.style.left = (75 + playerPos.x * scale) + 'px';
        p.style.top = (75 + playerPos.z * scale) + 'px';
    }
    
    function updateWaypoint() {
        var wp = document.getElementById('waypoint');
        var dist = document.getElementById('waypoint-dist');
        
        if (!activeMission || isInside || isOnBus) {
            wp.style.opacity = '0';
            dist.style.opacity = '0';
            return;
        }
        
        var m = missions[activeMission];
        if (!m || m.x === undefined) {
            wp.style.opacity = '0';
            dist.style.opacity = '0';
            return;
        }
        
        var dx = m.x - playerPos.x;
        var dz = m.z - playerPos.z;
        var d = Math.sqrt(dx * dx + dz * dz);
        var angle = Math.atan2(dx, -dz) - playerRot.y;
        
        wp.style.opacity = '1';
        wp.style.transform = 'translate(-50%, -50%) rotate(' + angle + 'rad)';
        dist.style.opacity = '1';
        dist.textContent = 'üìç ' + Math.round(d) + 'm - ' + m.npcName;
    }
    
    function updateMissionList() {
        var list = document.getElementById('mission-list');
        list.innerHTML = '';
        
        var missionKeys = Object.keys(missions).filter(function(k) {
            return completedMissions.indexOf(k) === -1 && missions[k].x !== undefined;
        });
        
        missionKeys.slice(0, 8).forEach(function(key) {
            var m = missions[key];
            var d = Math.sqrt((playerPos.x - m.x) ** 2 + (playerPos.z - m.z) ** 2);
            
            var div = document.createElement('div');
            div.className = 'mission-item' + (activeMission === key ? ' active' : '');
            div.innerHTML = m.icon + ' ' + m.npcName + '<span class="mission-dist">' + Math.round(d) + 'm</span>';
            div.onclick = function() {
                activeMission = key;
                updateMissionList();
            };
            list.appendChild(div);
        });
    }
    
    function showPrompt(type, data) {
        var p = document.getElementById('interact-prompt');
        var icons = { npc: data.icon || 'üë§', building: 'üö™', bus: 'üöå' };
        document.getElementById('prompt-icon').textContent = icons[type] || '‚ùì';
        document.getElementById('prompt-name').textContent = data.name || 'Unknown';
        document.getElementById('prompt-action').textContent = type === 'bus' ? 'Press SPACE to board' : 'Press SPACE';
        p.classList.remove('hidden');
    }
    
    function hidePrompt() { document.getElementById('interact-prompt').classList.add('hidden'); }
    
    function showPaper() {
        var paper;
        
        // Get paper based on current location
        if (isInside && currentInteriorKey) {
            var mission = missions[currentInteriorKey];
            if (mission && mission.buildingType) {
                paper = getPaperForLocation(mission.buildingType);
            } else if (currentInteriorKey === 'skyTower') {
                paper = getPaperForLocation('skyTower');
            }
        }
        
        // Fallback to location-based paper using nearby building
        if (!paper) {
            var nearestBuilding = null;
            var nearestDist = 50;
            buildingEntrances.forEach(function(b) {
                var dist = Math.sqrt(Math.pow(playerPos.x - b.x, 2) + Math.pow(playerPos.z - b.z, 2));
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestBuilding = b.key;
                }
            });
            if (nearestBuilding && missions[nearestBuilding] && missions[nearestBuilding].buildingType) {
                paper = getPaperForLocation(missions[nearestBuilding].buildingType);
            }
        }
        
        // Final fallback to random paper
        if (!paper) {
            var paperKeys = Object.keys(papers);
            paper = papers[paperKeys[Math.floor(Math.random() * paperKeys.length)]];
        }
        
        document.getElementById('paper-content').innerHTML = '<div class="paper-type">üì∞ ' + paper.type + '</div><h2>' + paper.title + '</h2>' + paper.content;
        document.getElementById('paper-viewer').classList.remove('hidden');
        collectedPapers++;
        score += 50;
        updateHUD();
    }
    
    function closePaper() { document.getElementById('paper-viewer').classList.add('hidden'); }
    
    // ============ BUS SYSTEM ============
    function boardBus() {
        if (!currentBus) return;
        isOnBus = true;
        document.getElementById('loc-name').textContent = 'üöå City Bus';
        hidePrompt();
        document.getElementById('minimap-panel').classList.add('hidden');
        document.getElementById('crosshair').classList.add('hidden');
        document.getElementById('bus-ui').classList.remove('hidden');
    }
    
    function exitBus() {
        isOnBus = false;
        document.getElementById('loc-name').textContent = 'City Streets';
        document.getElementById('minimap-panel').classList.remove('hidden');
        document.getElementById('crosshair').classList.remove('hidden');
        document.getElementById('bus-ui').classList.add('hidden');
    }
    
    function showBusRoutes() {
        var list = document.getElementById('bus-stops-list');
        list.innerHTML = '';
        
        busStops.forEach(function(stop) {
            var div = document.createElement('div');
            div.className = 'bus-stop';
            div.innerHTML = '<div class="bus-stop-name">üìç ' + stop.name + '</div><div class="bus-stop-desc">' + stop.desc + '</div>';
            div.onclick = function() { travelToStop(stop); };
            list.appendChild(div);
        });
        
        document.getElementById('bus-routes').classList.remove('hidden');
    }
    
    function closeBusRoutes() { document.getElementById('bus-routes').classList.add('hidden'); }
    
    function travelToStop(stop) {
        closeBusRoutes();
        exitBus();
        playerPos.x = stop.x;
        playerPos.z = stop.z;
        document.getElementById('loc-name').textContent = stop.name;
        score += 20;
        updateHUD();
    }
    
    // ============ BUILDING SYSTEM ============
    function enterBuilding() {
        if (!currentBuilding) return;
        var m = missions[currentBuilding.key];
        isInside = true;
        currentInteriorKey = currentBuilding.key;
        
        if (m.type === 'arcade') {
            isInArcade = true;
            document.getElementById('loc-name').textContent = m.buildingName;
            hidePrompt();
            document.getElementById('minimap-panel').classList.add('hidden');
            document.getElementById('crosshair').classList.add('hidden');
            document.getElementById('arcade-ui').classList.remove('hidden');
            createArcadeInterior();
        } else if (m.type === 'skyTower') {
            // Special handling for Sky Tower - elevator ride then restaurant
            isInElevator = true;
            document.getElementById('loc-name').textContent = 'üõó Elevator - Going Up...';
            hidePrompt();
            document.getElementById('minimap-panel').classList.add('hidden');
            document.getElementById('crosshair').classList.remove('hidden');
            document.getElementById('interior-ui').classList.remove('hidden');
            
            // Start elevator animation
            elevatorY = 0;
            elevatorTargetY = 115;
            
            // After delay, arrive at restaurant
            setTimeout(function() {
                isInElevator = false;
                document.getElementById('loc-name').textContent = m.buildingName;
                createSkyTowerInterior();
            }, 3000);
            
            // Create elevator interior temporarily
            createElevatorInterior();
        } else {
            document.getElementById('loc-name').textContent = m.buildingName;
            hidePrompt();
            document.getElementById('minimap-panel').classList.add('hidden');
            document.getElementById('crosshair').classList.remove('hidden');
            document.getElementById('interior-ui').classList.remove('hidden');
            createDetailedInterior(m);
        }
    }
    
    function createElevatorInterior() {
        interiorScene = new THREE.Scene();
        interiorScene.background = new THREE.Color(0x1a1a2e);
        
        interiorCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        
        // Elevator cab
        var cabMat = new THREE.MeshLambertMaterial({ color: 0x3a3a4a });
        var floorMat = new THREE.MeshLambertMaterial({ color: 0x2a2a3a });
        
        // Floor
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 3), floorMat));
        
        // Walls
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(3, 3, 0.1), cabMat).translateY(1.5).translateZ(-1.5));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 3, 3), cabMat).translateY(1.5).translateX(-1.5));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 3, 3), cabMat).translateY(1.5).translateX(1.5));
        
        // Glass front with city view
        var glassMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.3 });
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(3, 3, 0.05), glassMat).translateY(1.5).translateZ(1.5));
        
        // Ceiling with light
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 3), cabMat).translateY(3));
        interiorScene.add(new THREE.PointLight(0xffffee, 1, 5).translateY(2.8));
        
        // Control panel
        var panelMat = new THREE.MeshLambertMaterial({ color: 0x222233 });
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.8, 0.1), panelMat).translateY(1.2).translateX(1.3).translateZ(-1));
        
        // Floor indicator (digital display)
        var displayCanvas = document.createElement('canvas');
        displayCanvas.width = 64;
        displayCanvas.height = 32;
        var ctx = displayCanvas.getContext('2d');
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, 64, 32);
        ctx.fillStyle = '#0f0';
        ctx.font = 'bold 24px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('1', 32, 24);
        var displayTex = new THREE.CanvasTexture(displayCanvas);
        var display = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.05), new THREE.MeshBasicMaterial({ map: displayTex }));
        display.position.set(0, 2.7, -1.45);
        display.name = 'floorDisplay';
        interiorScene.add(display);
        
        // City visible through glass (rising view)
        for (var cv = 0; cv < 40; cv++) {
            var viewBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(3 + Math.random() * 5, 10 + Math.random() * 60, 3 + Math.random() * 5),
                new THREE.MeshLambertMaterial({ color: 0x222244 })
            );
            var dist = 20 + Math.random() * 80;
            var ang = Math.random() * Math.PI * 2;
            viewBuilding.position.set(Math.cos(ang) * dist, viewBuilding.geometry.parameters.height / 2, Math.sin(ang) * dist + 30);
            
            // Window lights
            for (var wl = 0; wl < 5; wl++) {
                var windowLight = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.3, 0.1),
                    new THREE.MeshBasicMaterial({ color: Math.random() > 0.3 ? 0xffffaa : 0x333333 })
                );
                windowLight.position.set(
                    viewBuilding.position.x + (Math.random() - 0.5) * 2,
                    5 + Math.random() * viewBuilding.geometry.parameters.height * 0.8,
                    viewBuilding.position.z - viewBuilding.geometry.parameters.depth / 2 - 0.1
                );
                interiorScene.add(windowLight);
            }
            
            interiorScene.add(viewBuilding);
        }
        
        // Ground
        var ground = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshLambertMaterial({ color: 0x1a2a1a }));
        ground.rotation.x = -Math.PI / 2;
        ground.position.set(0, 0, 50);
        ground.name = 'elevatorGround';
        interiorScene.add(ground);
        
        // Street lights below
        for (var sl = 0; sl < 30; sl++) {
            var streetLight = new THREE.PointLight(0xffaa44, 0.3, 20);
            streetLight.position.set((Math.random() - 0.5) * 200, 5, 30 + Math.random() * 100);
            interiorScene.add(streetLight);
        }
        
        interiorScene.add(new THREE.AmbientLight(0x404060, 0.3));
        
        interiorPlayerPos = { x: 0, z: 0 };
        interiorRot = { x: 0, y: 0 };
        interiorTargetRot = { x: 0, y: 0 };
    }
    
    function exitBuilding() {
        isInside = false;
        isInArcade = false;
        isInElevator = false;
        currentInteriorKey = null;
        interiorScene = null;
        interiorPlayerPos = { x: 0, z: 4 };
        interiorRot = { x: 0, y: 0 };
        interiorTargetRot = { x: 0, y: 0 };
        document.getElementById('loc-name').textContent = 'City Streets';
        document.getElementById('minimap-panel').classList.remove('hidden');
        document.getElementById('crosshair').classList.remove('hidden');
        document.getElementById('interior-ui').classList.add('hidden');
        document.getElementById('arcade-ui').classList.add('hidden');
    }
    
    // ============ ARCADE INTERIOR ============
    function createArcadeInterior() {
        interiorScene = new THREE.Scene();
        interiorScene.background = new THREE.Color(0x050510);
        interiorCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        interiorCamera.position.set(0, 5, 12);
        interiorCamera.lookAt(0, 2, 0);
        
        interiorScene.add(new THREE.AmbientLight(0x110022, 0.3));
        var neonPink = new THREE.PointLight(0xff00ff, 0.8, 15);
        neonPink.position.set(-5, 4, 0);
        interiorScene.add(neonPink);
        var neonCyan = new THREE.PointLight(0x00ffff, 0.8, 15);
        neonCyan.position.set(5, 4, 0);
        interiorScene.add(neonCyan);
        
        interiorScene.add(new THREE.Mesh(new THREE.PlaneGeometry(20, 16), new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.3, metalness: 0.5 })).rotateX(-Math.PI / 2));
        
        var wallMat = new THREE.MeshStandardMaterial({ color: 0x0a0a1a, roughness: 0.8 });
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(20, 6, 0.2), wallMat).translateZ(-7.9).translateY(3));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.2, 6, 16), wallMat).translateX(-9.9).translateY(3));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.2, 6, 16), wallMat).translateX(9.9).translateY(3));
        
        [{ x: -6, c: 0xff0066 }, { x: -3, c: 0x00ff66 }, { x: 0, c: 0xffff00 }, { x: 3, c: 0x00ffff }, { x: 6, c: 0xff00ff }].forEach(function(pos) {
            var cab = new THREE.Group();
            cab.add(new THREE.Mesh(new THREE.BoxGeometry(1.8, 4, 1.5), new THREE.MeshStandardMaterial({ color: 0x111111 })).translateY(2));
            cab.add(new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.2, 0.1), new THREE.MeshBasicMaterial({ color: pos.c })).translateY(3.2).translateZ(0.76));
            var light = new THREE.PointLight(pos.c, 0.3, 3);
            light.position.set(0, 3, 1.5);
            cab.add(light);
            cab.position.set(pos.x, 0, -4);
            interiorScene.add(cab);
        });
        
        var npc = createPerson(0x660066, 0xffd5b4, 0x00ffff);
        npc.position.set(4, 0, 0);
        interiorScene.add(npc);
    }
    
    // ============ DETAILED INTERIOR WITH DECORATIONS ============
    function createDetailedInterior(mission) {
        interiorScene = new THREE.Scene();
        var type = mission.buildingType || 'clothing';
        var bgColors = { clothing: 0x1a1515, electronics: 0x0a0a15, pharmacy: 0x151a15, restaurant: 0x1a1510, bank: 0x10101a, cafe: 0x1a1510, bookstore: 0x15100a, gym: 0x101010, hotel: 0x1a1515, gallery: 0x151515, supermarket: 0x151515, stadium: 0x0a1a0a, disco: 0x0a0a1a, cathedral: 0x1a1a15 };
        interiorScene.background = new THREE.Color(bgColors[type] || 0x151515);
        
        interiorCamera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 100);
        
        interiorScene.add(new THREE.AmbientLight(0xffffff, 0.25));
        interiorScene.add(new THREE.HemisphereLight(0xffeedd, 0x333355, 0.4));
        
        // Spotlights
        for (var sx = -4; sx <= 4; sx += 4) {
            var spot = new THREE.SpotLight(0xffffff, 0.5, 15, Math.PI / 4, 0.5);
            spot.position.set(sx, 6, 0);
            interiorScene.add(spot);
        }
        
        // FLOOR based on type
        var floorColors = { clothing: 0x8b7355, electronics: 0x2a2a3a, pharmacy: 0xeeeeee, restaurant: 0x5a3a2a, bank: 0x3a3a4a, cafe: 0x6a5040, bookstore: 0x4a3a2a, gym: 0x333333, hotel: 0x8b6355, gallery: 0xfafafa, supermarket: 0xdddddd, stadium: 0x2a5a2a, disco: 0x1a1a2a, cathedral: 0x6a6a5a };
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(18, 0.1, 16), new THREE.MeshStandardMaterial({ color: floorColors[type] || 0x4a4035, roughness: 0.7 })));
        
        // WALLS
        var wallColors = { disco: 0x1a1a2a, stadium: 0x3a5a3a, cathedral: 0x8b8b7b };
        var wallMat = new THREE.MeshStandardMaterial({ color: wallColors[type] || 0x555555, roughness: 0.85 });
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(18, 5, 0.2), wallMat).translateZ(-7.9).translateY(2.5));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 16), wallMat).translateX(-8.9).translateY(2.5));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 16), wallMat).translateX(8.9).translateY(2.5));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(18, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0x333333 })).translateY(5));
        
        // TYPE-SPECIFIC DECORATIONS
        if (type === 'clothing') {
            addClothingDecor();
        } else if (type === 'electronics') {
            addElectronicsDecor();
        } else if (type === 'pharmacy') {
            addPharmacyDecor();
        } else if (type === 'restaurant') {
            addRestaurantDecor();
        } else if (type === 'cafe') {
            addCafeDecor();
        } else if (type === 'bookstore') {
            addBookstoreDecor();
        } else if (type === 'gym') {
            addGymDecor();
        } else if (type === 'bank') {
            addBankDecor();
        } else if (type === 'hotel') {
            addHotelDecor();
        } else if (type === 'gallery') {
            addGalleryDecor();
        } else if (type === 'supermarket') {
            addSupermarketDecor();
        } else if (type === 'stadium') {
            addStadiumDecor();
        } else if (type === 'disco') {
            addDiscoDecor();
        } else if (type === 'cathedral') {
            addCathedralDecor();
        }
        
        // ADD PHYSICAL PAPERS/MAGAZINES specific to each location
        addLocationPapers(type);
        
        // COUNTER (for shops)
        if (['clothing', 'electronics', 'pharmacy', 'cafe', 'bookstore', 'bank', 'supermarket'].includes(type)) {
            interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(6, 1.1, 1.2), new THREE.MeshStandardMaterial({ color: 0x5a4a3a, roughness: 0.7 })).translateY(0.55).translateZ(-5));
        }
        
        // NPC (shop keeper / staff)
        var colors = { clothing: 0xec4899, electronics: 0x0ea5e9, pharmacy: 0x06b6d4, restaurant: 0xb91c1c, bank: 0x1e40af, cafe: 0x78350f, bookstore: 0x92400e, gym: 0xdc2626, hotel: 0xd97706, gallery: 0x7c3aed, supermarket: 0x059669, stadium: 0x16a34a, disco: 0xe91e63, cathedral: 0x4a4a4a };
        var npc = createPerson(colors[type] || 0x666666);
        npc.position.set(0, 0, -5);
        npc.userData.isShopkeeper = true;
        interiorScene.add(npc);
        
        // Add ambient customers/visitors
        addInteriorPeople(type);
        
        interiorPlayerPos = { x: 0, z: 5 };
        interiorRot = { x: 0, y: 0 };
        interiorTargetRot = { x: 0, y: 0 };
    }
    
    // Physical papers inside establishments
    function addLocationPapers(type) {
        var paperColors = {
            clothing: 0xff69b4,
            electronics: 0x00bcd4,
            pharmacy: 0x4caf50,
            restaurant: 0xf44336,
            cafe: 0x795548,
            bookstore: 0x9c27b0,
            gym: 0xff5722,
            bank: 0x2196f3,
            hotel: 0xffc107,
            gallery: 0x673ab7,
            supermarket: 0x8bc34a,
            stadium: 0x4caf50,
            disco: 0xe91e63,
            cathedral: 0x607d8b
        };
        
        var paperPositions = [
            { x: -5, y: 0.85, z: 2 },
            { x: 5, y: 0.85, z: 2 },
            { x: -3, y: 1.2, z: -3 },
            { x: 3, y: 0.75, z: 0 }
        ];
        
        paperPositions.forEach(function(pos, idx) {
            if (Math.random() > 0.6) return; // Not all positions have papers
            
            var paperGroup = new THREE.Group();
            
            // Magazine/paper base
            var paperMesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.02, 0.55),
                new THREE.MeshStandardMaterial({ 
                    color: paperColors[type] || 0xeeeeee,
                    roughness: 0.8
                })
            );
            paperGroup.add(paperMesh);
            
            // Cover image simulation
            var coverCanvas = document.createElement('canvas');
            coverCanvas.width = 64;
            coverCanvas.height = 80;
            var ctx = coverCanvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 64, 80);
            ctx.fillStyle = '#' + (paperColors[type] || 0xeeeeee).toString(16).padStart(6, '0');
            ctx.fillRect(5, 5, 54, 30);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 8px Arial';
            ctx.fillText(type.toUpperCase(), 10, 55);
            ctx.fillStyle = '#666';
            ctx.font = '6px Arial';
            ctx.fillText('MAGAZINE', 10, 65);
            
            var coverTex = new THREE.CanvasTexture(coverCanvas);
            var cover = new THREE.Mesh(
                new THREE.PlaneGeometry(0.38, 0.5),
                new THREE.MeshBasicMaterial({ map: coverTex })
            );
            cover.rotation.x = -Math.PI / 2;
            cover.position.y = 0.015;
            paperGroup.add(cover);
            
            // Glowing highlight
            var glow = new THREE.PointLight(paperColors[type] || 0xffffff, 0.3, 2);
            glow.position.y = 0.2;
            paperGroup.add(glow);
            
            paperGroup.position.set(pos.x, pos.y, pos.z);
            paperGroup.rotation.y = Math.random() * 0.5 - 0.25;
            paperGroup.userData.isPaper = true;
            paperGroup.userData.locationType = type;
            
            interiorScene.add(paperGroup);
        });
    }
    
    // Add customers/visitors to interiors
    function addInteriorPeople(type) {
        var numPeople = { clothing: 4, electronics: 3, pharmacy: 2, restaurant: 6, cafe: 5, bookstore: 3, gym: 5, bank: 3, hotel: 2, gallery: 4, supermarket: 5, stadium: 8, disco: 12, cathedral: 6 };
        var count = numPeople[type] || 3;
        
        for (var i = 0; i < count; i++) {
            var person = createPerson();
            person.position.set(
                (Math.random() - 0.5) * 12,
                0,
                (Math.random() - 0.5) * 8
            );
            person.rotation.y = Math.random() * Math.PI * 2;
            
            // Different behaviors based on location
            if (type === 'disco') {
                person.userData.dancing = true;
                person.userData.danceOffset = Math.random() * Math.PI * 2;
            } else if (type === 'gym') {
                person.userData.exercising = true;
            } else if (type === 'restaurant' || type === 'cafe') {
                person.userData.seated = true;
                person.scale.y = 0.7; // Sitting
            }
            
            interiorScene.add(person);
        }
    }
    
    // DECORATION FUNCTIONS FOR EACH TYPE
    function addClothingDecor() {
        // Clothing racks
        for (var i = -6; i <= 6; i += 4) {
            var rack = new THREE.Group();
            rack.add(new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2), new THREE.MeshLambertMaterial({ color: 0x888888 })).translateY(1.5));
            rack.add(new THREE.Mesh(new THREE.BoxGeometry(2, 0.05, 0.05), new THREE.MeshLambertMaterial({ color: 0x888888 })).translateY(2.5));
            // Clothes hanging
            for (var c = -0.8; c <= 0.8; c += 0.4) {
                var clothColor = [0xe74c3c, 0x3498db, 0x2ecc71, 0x9b59b6, 0xf1c40f][Math.floor(Math.random() * 5)];
                rack.add(new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.6, 0.08), new THREE.MeshLambertMaterial({ color: clothColor })).translateY(2.1).translateX(c));
            }
            rack.position.set(i, 0, Math.random() > 0.5 ? -2 : 2);
            interiorScene.add(rack);
        }
        // Mannequins
        var mann1 = createPerson(0xff69b4);
        mann1.position.set(-6, 0, 0);
        interiorScene.add(mann1);
        var mann2 = createPerson(0x00bcd4);
        mann2.position.set(6, 0, 0);
        interiorScene.add(mann2);
        // Mirror
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(2, 3, 0.1), new THREE.MeshBasicMaterial({ color: 0xccddee })).translateY(1.8).translateX(7).translateZ(0));
    }
    
    function addElectronicsDecor() {
        // TV Displays
        for (var i = -6; i <= 6; i += 3) {
            var tv = new THREE.Group();
            tv.add(new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 0.1), new THREE.MeshLambertMaterial({ color: 0x111111 })).translateY(1.5));
            tv.add(new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.8, 0.05), new THREE.MeshBasicMaterial({ color: 0x00aaff })).translateY(1.5).translateZ(0.06));
            tv.position.set(i, 0, -6);
            interiorScene.add(tv);
        }
        // Phone displays
        for (var j = -5; j <= 5; j += 2.5) {
            var table = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 0.8), new THREE.MeshLambertMaterial({ color: 0xeeeeee }));
            table.position.set(j, 0.4, 0);
            interiorScene.add(table);
            var phone = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.02, 0.3), new THREE.MeshBasicMaterial({ color: 0x333333 }));
            phone.position.set(j, 0.85, 0);
            interiorScene.add(phone);
        }
        // Neon lights
        var neon1 = new THREE.PointLight(0x00ffff, 0.8, 10);
        neon1.position.set(-5, 3, 0);
        interiorScene.add(neon1);
        var neon2 = new THREE.PointLight(0xff00ff, 0.8, 10);
        neon2.position.set(5, 3, 0);
        interiorScene.add(neon2);
    }
    
    function addPharmacyDecor() {
        // Medicine shelves
        for (var x = -6; x <= 6; x += 4) {
            var shelf = new THREE.Group();
            for (var y = 0; y < 3; y++) {
                shelf.add(new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 0.6), new THREE.MeshLambertMaterial({ color: 0xffffff })).translateY(1 + y * 0.8));
                // Medicine boxes
                for (var b = -0.8; b <= 0.8; b += 0.4) {
                    var boxColor = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xffeaa7][Math.floor(Math.random() * 5)];
                    shelf.add(new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.25, 0.2), new THREE.MeshLambertMaterial({ color: boxColor })).translateY(1.2 + y * 0.8).translateX(b));
                }
            }
            shelf.position.set(x, 0, -3);
            interiorScene.add(shelf);
        }
        // Green cross sign
        var cross = new THREE.Group();
        cross.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.25, 0.1), new THREE.MeshBasicMaterial({ color: 0x00ff00 })));
        cross.add(new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.1), new THREE.MeshBasicMaterial({ color: 0x00ff00 })));
        cross.position.set(0, 4, -7.5);
        interiorScene.add(cross);
    }
    
    function addRestaurantDecor() {
        // Dining tables
        for (var x = -5; x <= 5; x += 3.5) {
            for (var z = -2; z <= 3; z += 3) {
                var table = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.05, 16), new THREE.MeshLambertMaterial({ color: 0xffffff }));
                table.position.set(x, 0.75, z);
                interiorScene.add(table);
                var leg = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.7), new THREE.MeshLambertMaterial({ color: 0x333333 }));
                leg.position.set(x, 0.35, z);
                interiorScene.add(leg);
                // Chairs
                for (var a = 0; a < 4; a++) {
                    var chair = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.5, 0.35), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                    chair.position.set(x + Math.cos(a * Math.PI/2) * 0.9, 0.25, z + Math.sin(a * Math.PI/2) * 0.9);
                    interiorScene.add(chair);
                }
            }
        }
        // Candles on tables
        interiorScene.add(new THREE.PointLight(0xffaa44, 0.3, 5).translateY(1).translateX(-5));
        interiorScene.add(new THREE.PointLight(0xffaa44, 0.3, 5).translateY(1).translateX(5));
    }
    
    function addCafeDecor() {
        // Coffee bar
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(8, 1.2, 1), new THREE.MeshLambertMaterial({ color: 0x5a3a2a })).translateY(0.6).translateZ(-5.5));
        // Coffee machine
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.5), new THREE.MeshLambertMaterial({ color: 0x888888 })).translateY(1.6).translateZ(-6).translateX(-2));
        // Small tables
        for (var i = -4; i <= 4; i += 2.5) {
            interiorScene.add(new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.7, 8), new THREE.MeshLambertMaterial({ color: 0x333333 })).translateY(0.35).translateX(i).translateZ(2));
            interiorScene.add(new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.05, 16), new THREE.MeshLambertMaterial({ color: 0x8b6355 })).translateY(0.72).translateX(i).translateZ(2));
        }
        // Warm lighting
        interiorScene.add(new THREE.PointLight(0xffcc88, 0.6, 15).translateY(3));
    }
    
    function addBookstoreDecor() {
        // Bookshelves
        for (var x = -7; x <= 7; x += 3.5) {
            var shelf = new THREE.Group();
            shelf.add(new THREE.Mesh(new THREE.BoxGeometry(2.5, 3, 0.5), new THREE.MeshLambertMaterial({ color: 0x5a3a2a })).translateY(1.5));
            // Books
            for (var row = 0; row < 4; row++) {
                for (var b = -0.9; b <= 0.9; b += 0.2) {
                    var bookColor = [0xe74c3c, 0x3498db, 0x2ecc71, 0xf1c40f, 0x9b59b6, 0x1abc9c][Math.floor(Math.random() * 6)];
                    shelf.add(new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.55, 0.35), new THREE.MeshLambertMaterial({ color: bookColor })).translateY(0.5 + row * 0.7).translateX(b).translateZ(0.1));
                }
            }
            shelf.position.set(x, 0, -4);
            interiorScene.add(shelf);
        }
        // Reading corner
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 1.5), new THREE.MeshLambertMaterial({ color: 0x8b4513 })).translateY(0.25).translateX(5).translateZ(3));
    }
    
    function addGymDecor() {
        // Treadmills
        for (var i = -5; i <= 5; i += 2.5) {
            var tread = new THREE.Group();
            tread.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 2), new THREE.MeshLambertMaterial({ color: 0x333333 })).translateY(0.15));
            tread.add(new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.05, 1.5), new THREE.MeshLambertMaterial({ color: 0x1a1a1a })).translateY(0.28));
            tread.add(new THREE.Mesh(new THREE.BoxGeometry(0.05, 1.2, 0.05), new THREE.MeshLambertMaterial({ color: 0x666666 })).translateY(0.85).translateZ(-0.8).translateX(0.3));
            tread.add(new THREE.Mesh(new THREE.BoxGeometry(0.05, 1.2, 0.05), new THREE.MeshLambertMaterial({ color: 0x666666 })).translateY(0.85).translateZ(-0.8).translateX(-0.3));
            tread.position.set(i, 0, -3);
            interiorScene.add(tread);
        }
        // Weights
        for (var w = -6; w <= 6; w += 2) {
            var weight = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.15, 16), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
            weight.rotation.z = Math.PI / 2;
            weight.position.set(w, 0.15, 3);
            interiorScene.add(weight);
        }
        // Mirror wall
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(16, 3.5, 0.1), new THREE.MeshBasicMaterial({ color: 0xaabbcc })).translateY(2).translateZ(-7.5));
    }
    
    function addBankDecor() {
        // Marble floor effect
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(16, 0.02, 14), new THREE.MeshStandardMaterial({ color: 0xfaf0e6, metalness: 0.3, roughness: 0.2 })).translateY(0.06));
        // Columns
        for (var x = -5; x <= 5; x += 5) {
            interiorScene.add(new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 4.5, 16), new THREE.MeshLambertMaterial({ color: 0xddd5c5 })).translateY(2.25).translateX(x));
        }
        // Teller windows
        for (var t = -4; t <= 4; t += 4) {
            interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(2.5, 2, 0.3), new THREE.MeshLambertMaterial({ color: 0x4a3a2a })).translateY(1.5).translateZ(-6).translateX(t));
            interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(1.8, 1, 0.1), new THREE.MeshBasicMaterial({ color: 0x88aacc, transparent: true, opacity: 0.5 })).translateY(2).translateZ(-5.8).translateX(t));
        }
    }
    
    function addHotelDecor() {
        // Reception desk
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(6, 1.2, 1.5), new THREE.MeshLambertMaterial({ color: 0x5a3a2a })).translateY(0.6).translateZ(-5));
        // Chandelier
        var chand = new THREE.Group();
        chand.add(new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffcc })));
        chand.add(new THREE.PointLight(0xffffcc, 1, 15));
        chand.position.set(0, 4, 0);
        interiorScene.add(chand);
        // Sofas
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(3, 0.6, 1), new THREE.MeshLambertMaterial({ color: 0x8b0000 })).translateY(0.3).translateX(-4).translateZ(2));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(3, 0.6, 1), new THREE.MeshLambertMaterial({ color: 0x8b0000 })).translateY(0.3).translateX(4).translateZ(2));
        // Plants
        interiorScene.add(new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.6, 8), new THREE.MeshLambertMaterial({ color: 0x5a3a2a })).translateY(0.3).translateX(-7).translateZ(-3));
        interiorScene.add(new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshLambertMaterial({ color: 0x228b22 })).translateY(0.9).translateX(-7).translateZ(-3));
    }
    
    function addGalleryDecor() {
        // Paintings on walls
        var paintingColors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7, 0x00b894];
        for (var i = 0; i < 6; i++) {
            var frame = new THREE.Group();
            frame.add(new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 0.1), new THREE.MeshLambertMaterial({ color: 0x2a2a2a })));
            frame.add(new THREE.Mesh(new THREE.BoxGeometry(1.7, 1.2, 0.05), new THREE.MeshBasicMaterial({ color: paintingColors[i] })).translateZ(0.05));
            frame.position.set(-6 + i * 2.5, 2.2, -7.5);
            interiorScene.add(frame);
        }
        // Sculptures
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshLambertMaterial({ color: 0xffffff })).translateY(0.9).translateX(-4).translateZ(0));
        interiorScene.add(new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshLambertMaterial({ color: 0xffffff })).translateY(1.8).translateX(-4).translateZ(0));
        interiorScene.add(new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.5, 8), new THREE.MeshLambertMaterial({ color: 0xcccccc })).translateY(1.5).translateX(4).translateZ(0));
        // Spotlights on art
        for (var s = -6; s <= 6; s += 3) {
            var artLight = new THREE.SpotLight(0xffffff, 0.5, 8, Math.PI/6, 0.5);
            artLight.position.set(s, 4.5, -5);
            artLight.target.position.set(s, 2, -7.5);
            interiorScene.add(artLight);
        }
    }
    
    function addSupermarketDecor() {
        // Aisles with shelves
        for (var aisle = -6; aisle <= 6; aisle += 4) {
            var shelf = new THREE.Group();
            shelf.add(new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 6), new THREE.MeshLambertMaterial({ color: 0x666666 })).translateY(1.25));
            // Products
            for (var p = -2.5; p <= 2.5; p += 0.5) {
                for (var h = 0; h < 3; h++) {
                    var prodColor = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff8800, 0x8800ff][Math.floor(Math.random() * 6)];
                    shelf.add(new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.35, 0.2), new THREE.MeshLambertMaterial({ color: prodColor })).translateY(0.6 + h * 0.7).translateZ(p).translateX(0.5));
                    shelf.add(new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.35, 0.2), new THREE.MeshLambertMaterial({ color: prodColor })).translateY(0.6 + h * 0.7).translateZ(p).translateX(-0.5));
                }
            }
            shelf.position.set(aisle, 0, -1);
            interiorScene.add(shelf);
        }
        // Checkout
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(2, 0.9, 0.6), new THREE.MeshLambertMaterial({ color: 0x333333 })).translateY(0.45).translateZ(5).translateX(-5));
    }
    
    function addStadiumDecor() {
        // Green field
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(14, 0.05, 10), new THREE.MeshLambertMaterial({ color: 0x228b22 })).translateY(0.06).translateZ(-1));
        // Field lines
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(14, 0.06, 0.1), new THREE.MeshBasicMaterial({ color: 0xffffff })).translateY(0.08).translateZ(-1));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.06, 10), new THREE.MeshBasicMaterial({ color: 0xffffff })).translateY(0.08).translateZ(-1));
        // Goals
        var goalMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 2), goalMat).translateY(0.75).translateX(-7).translateZ(-1));
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 2), goalMat).translateY(0.75).translateX(7).translateZ(-1));
        // Stands (bleachers)
        for (var row = 0; row < 3; row++) {
            interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(16, 0.3, 1.5), new THREE.MeshLambertMaterial({ color: 0x1e40af })).translateY(0.5 + row * 0.5).translateZ(-6 - row * 0.8));
        }
        // Spectators (simplified)
        for (var sp = 0; sp < 15; sp++) {
            var spectator = createPerson();
            spectator.scale.set(0.5, 0.5, 0.5);
            spectator.position.set(-6 + sp * 0.85, 0.8, -6.5);
            interiorScene.add(spectator);
        }
        // Stadium lights
        interiorScene.add(new THREE.PointLight(0xffffff, 1, 20).translateY(4.5));
    }
    
    function addDiscoDecor() {
        // Dance floor with colored tiles
        var colors = [0xff0066, 0x00ffff, 0xffff00, 0xff00ff, 0x00ff00, 0xff8800];
        for (var dx = -6; dx <= 6; dx += 2) {
            for (var dz = -4; dz <= 4; dz += 2) {
                var tileColor = colors[Math.floor(Math.random() * colors.length)];
                var tile = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.05, 1.8), new THREE.MeshBasicMaterial({ color: tileColor }));
                tile.position.set(dx, 0.06, dz);
                interiorScene.add(tile);
            }
        }
        // Disco ball
        var ball = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 1, roughness: 0.1 }));
        ball.position.set(0, 4.2, 0);
        interiorScene.add(ball);
        // Rotating lights
        var discoLight1 = new THREE.PointLight(0xff0066, 1.5, 15);
        discoLight1.position.set(-3, 3.5, 0);
        interiorScene.add(discoLight1);
        var discoLight2 = new THREE.PointLight(0x00ffff, 1.5, 15);
        discoLight2.position.set(3, 3.5, 0);
        interiorScene.add(discoLight2);
        var discoLight3 = new THREE.PointLight(0xffff00, 1.5, 15);
        discoLight3.position.set(0, 3.5, 3);
        interiorScene.add(discoLight3);
        // DJ booth
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 1), new THREE.MeshLambertMaterial({ color: 0x1a1a1a })).translateY(0.6).translateZ(-6));
        var dj = createPerson(0x9b59b6);
        dj.position.set(0, 0, -5.5);
        interiorScene.add(dj);
        // Dancing people
        for (var d = 0; d < 12; d++) {
            var dancer = createPerson(null, null, null, { dancing: true });
            dancer.position.set(-5 + (d % 4) * 3.3, 0, -2 + Math.floor(d / 4) * 3);
            dancer.userData.dancing = true;
            dancer.userData.danceOffset = Math.random() * Math.PI * 2;
            interiorScene.add(dancer);
        }
    }
    
    function addCathedralDecor() {
        // Pews (benches)
        for (var row = 0; row < 4; row++) {
            for (var side = -1; side <= 1; side += 2) {
                var pew = new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 0.6), new THREE.MeshLambertMaterial({ color: 0x5a3a2a }));
                pew.position.set(side * 3, 0.4, 1 + row * 1.8);
                interiorScene.add(pew);
            }
        }
        // Altar
        interiorScene.add(new THREE.Mesh(new THREE.BoxGeometry(4, 1, 2), new THREE.MeshLambertMaterial({ color: 0xfaf0e6 })).translateY(0.5).translateZ(-6));
        // Candles
        for (var c = -1.5; c <= 1.5; c += 1) {
            var candle = new THREE.Group();
            candle.add(new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.4), new THREE.MeshLambertMaterial({ color: 0xfffff0 })).translateY(1.2));
            candle.add(new THREE.PointLight(0xffaa44, 0.3, 3).translateY(1.5));
            candle.position.set(c, 0, -6);
            interiorScene.add(candle);
        }
        // Stained glass effect (back wall colors)
        var stainedColors = [0xff4488, 0x4488ff, 0x44ff88, 0xffff44, 0xff8844];
        for (var sg = 0; sg < 5; sg++) {
            var glass = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 0.1), new THREE.MeshBasicMaterial({ color: stainedColors[sg], transparent: true, opacity: 0.6 }));
            glass.position.set(-5 + sg * 2.5, 3, -7.8);
            interiorScene.add(glass);
        }
        // Organ pipes
        for (var pipe = 0; pipe < 7; pipe++) {
            var pipeHeight = 1.5 + Math.sin(pipe * 0.8) * 0.8;
            interiorScene.add(new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, pipeHeight), new THREE.MeshLambertMaterial({ color: 0x888888 })).translateY(3 + pipeHeight/2).translateZ(-7.5).translateX(-3 + pipe * 0.6));
        }
    }
    
    function updateInterior() {
        if (!interiorScene || !interiorCamera) return;
        
        // Arrow keys for turning
        if (keys['ArrowLeft']) interiorTargetRot.y += 0.045;
        if (keys['ArrowRight']) interiorTargetRot.y -= 0.045;
        
        // Direct rotation - no lag
        interiorRot.x = interiorTargetRot.x;
        interiorRot.y = interiorTargetRot.y;
        
        // Calculate forward and right vectors
        var forwardX = -Math.sin(interiorRot.y);
        var forwardZ = -Math.cos(interiorRot.y);
        var rightX = Math.cos(interiorRot.y);
        var rightZ = -Math.sin(interiorRot.y);
        
        var speed = 0.12;
        var moveX = 0, moveZ = 0;
        
        // W = forward
        if (keys['KeyW'] || keys['ArrowUp']) {
            moveX += forwardX;
            moveZ += forwardZ;
        }
        // S = backward
        if (keys['KeyS'] || keys['ArrowDown']) {
            moveX -= forwardX;
            moveZ -= forwardZ;
        }
        // D = strafe right
        if (keys['KeyD']) {
            moveX += rightX;
            moveZ += rightZ;
        }
        // A = strafe left
        if (keys['KeyA']) {
            moveX -= rightX;
            moveZ -= rightZ;
        }
        
        // Apply movement
        if (moveX !== 0 || moveZ !== 0) {
            var len = Math.sqrt(moveX * moveX + moveZ * moveZ);
            interiorPlayerPos.x += (moveX / len) * speed;
            interiorPlayerPos.z += (moveZ / len) * speed;
        }
        
        interiorPlayerPos.x = Math.max(-7, Math.min(7, interiorPlayerPos.x));
        interiorPlayerPos.z = Math.max(-4, Math.min(7, interiorPlayerPos.z));
        
        interiorCamera.position.set(interiorPlayerPos.x, 1.7, interiorPlayerPos.z);
        interiorCamera.rotation.order = 'YXZ';
        interiorCamera.rotation.y = interiorRot.y;
        interiorCamera.rotation.x = interiorRot.x;
        
        // Animate NPCs in interior
        interiorScene.children.forEach(function(child) {
            if (child.userData && child.userData.dancing) {
                // Dance animation
                var phase = animTime * 8 + (child.userData.danceOffset || 0);
                child.position.y = Math.abs(Math.sin(phase)) * 0.15;
                child.rotation.y = Math.sin(phase * 0.5) * 0.3;
                
                // Arms swing
                if (child.children.length > 4) {
                    if (child.children[2]) child.children[2].rotation.z = Math.sin(phase) * 0.8 - 0.5;
                    if (child.children[4]) child.children[4].rotation.z = Math.cos(phase) * 0.8 + 0.5;
                }
            }
        });
        
        // Disco lights animation
        if (currentInteriorKey === 'disco') {
            var discoPhase = animTime * 3;
            interiorScene.children.forEach(function(child) {
                if (child.type === 'PointLight' && child.position.y > 3 && child.position.y < 4) {
                    child.intensity = 0.8 + Math.sin(discoPhase + child.position.x) * 0.7;
                }
            });
        }
    }
    
    // ============ DIALOGUE SYSTEM ============
    function startDialogue(missionKey) {
        currentMission = missions[missionKey];
        if (!currentMission) return;
        currentMission.key = missionKey;
        dialogueIndex = 0;
        renderDialogue();
        document.getElementById('dialogue-overlay').classList.remove('hidden');
    }
    
    function renderDialogue() {
        if (!currentMission || !currentMission.dialogues[dialogueIndex]) return;
        var d = currentMission.dialogues[dialogueIndex];
        document.getElementById('dlg-icon').textContent = currentMission.icon;
        document.getElementById('dlg-name').textContent = currentMission.npcName;
        document.getElementById('dlg-grammar').textContent = d.grammar;
        document.getElementById('dlg-text').textContent = '"' + d.npc + '"';
        
        var opts = document.getElementById('dlg-options');
        opts.innerHTML = '';
        d.options.forEach(function(o, i) {
            var btn = document.createElement('button');
            btn.className = 'dlg-option';
            btn.innerHTML = '<span class="letter">' + String.fromCharCode(65 + i) + '.</span> ' + o.text;
            btn.onclick = function(e) { e.stopPropagation(); handleAnswer(o); };
            opts.appendChild(btn);
        });
        
        document.getElementById('dlg-feedback').innerHTML = '';
        
        var vocab = document.getElementById('dlg-vocab-list');
        vocab.innerHTML = '';
        if (currentMission.vocabulary) {
            currentMission.vocabulary.forEach(function(w) {
                var s = document.createElement('span');
                s.className = 'vocab-word';
                s.textContent = w;
                s.onclick = function(e) { e.stopPropagation(); speak(w); };
                vocab.appendChild(s);
            });
        }
    }
    
    function handleAnswer(opt) {
        var fb = document.getElementById('dlg-feedback');
        if (opt.correct) {
            score += 100;
            fb.innerHTML = '<div class="dlg-feedback correct">‚úì Excellent C1-level response! +100 points</div>';
            document.getElementById('dlg-options').innerHTML = '';
            
            setTimeout(function() {
                if (dialogueIndex + 1 < currentMission.dialogues.length) {
                    dialogueIndex++;
                    renderDialogue();
                } else {
                    if (completedMissions.indexOf(currentMission.key) === -1) {
                        completedMissions.push(currentMission.key);
                        score += 500;
                        fb.innerHTML = '<div class="dlg-feedback correct">üéâ MISSION COMPLETE! +500 Bonus!</div>';
                    }
                    if (activeMission === currentMission.key) activeMission = null;
                    setTimeout(closeDialogue, 1500);
                    updateMissionList();
                }
                updateHUD();
            }, 1500);
        } else {
            fb.innerHTML = '<div class="dlg-feedback incorrect">‚úó Try using more sophisticated C1 structures!</div>';
        }
        updateHUD();
    }
    
    function closeDialogue() {
        speechSynthesis.cancel();
        document.getElementById('dialogue-overlay').classList.add('hidden');
        currentMission = null;
    }
    
    // ============ 3D HELPERS ============
    function createPerson(bodyColor, skinColor, hairColor, options) {
        options = options || {};
        var g = new THREE.Group();
        
        // Skin tones variety
        var skinTones = [0xffd5b4, 0xe8beac, 0xd4a574, 0xc68642, 0x8d5524, 0x6b4423, 0xf5d0c5, 0xdeb887];
        var actualSkin = skinColor || skinTones[Math.floor(Math.random() * skinTones.length)];
        
        // Hair colors and styles
        var hairColors = [0x4a3728, 0x2c2c2c, 0x8b4513, 0x333333, 0xd4a574, 0xffd700, 0xff4500, 0x800020, 0x1a1a2e, 0xe8e8e8, 0xff69b4, 0x00bfff];
        var actualHair = hairColor || hairColors[Math.floor(Math.random() * hairColors.length)];
        var hairStyle = options.hairStyle || Math.floor(Math.random() * 6);
        
        // Body colors (clothes)
        var clothesColors = [0x3498db, 0xe74c3c, 0x2ecc71, 0x9b59b6, 0xf39c12, 0x1abc9c, 0x34495e, 0xe91e63, 0x00bcd4, 0xff5722, 0x673ab7, 0x009688, 0xffc107, 0x795548, 0x607d8b];
        var actualBody = bodyColor || clothesColors[Math.floor(Math.random() * clothesColors.length)];
        
        // Gender (affects body shape slightly)
        var isFemale = options.female !== undefined ? options.female : Math.random() > 0.5;
        
        // BODY (Torso with clothes)
        var torsoWidth = isFemale ? 0.45 : 0.55;
        var torsoHeight = isFemale ? 0.65 : 0.75;
        var torso = new THREE.Mesh(
            new THREE.BoxGeometry(torsoWidth, torsoHeight, 0.28),
            new THREE.MeshLambertMaterial({ color: actualBody })
        );
        torso.position.y = 1.0;
        g.add(torso);
        
        // Shirt detail / collar
        var collarColor = Math.random() > 0.5 ? 0xffffff : actualBody - 0x222222;
        var collar = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.08, 0.15),
            new THREE.MeshLambertMaterial({ color: collarColor })
        );
        collar.position.set(0, 1.35, 0.08);
        g.add(collar);
        
        // Arms
        var armColor = Math.random() > 0.3 ? actualBody : actualSkin; // Long or short sleeves
        var leftArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.45, 0.12),
            new THREE.MeshLambertMaterial({ color: armColor })
        );
        leftArm.position.set(torsoWidth/2 + 0.08, 0.95, 0);
        leftArm.rotation.z = options.dancing ? Math.sin(Date.now() * 0.01) * 0.5 : -0.1;
        g.add(leftArm);
        
        var rightArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.45, 0.12),
            new THREE.MeshLambertMaterial({ color: armColor })
        );
        rightArm.position.set(-torsoWidth/2 - 0.08, 0.95, 0);
        rightArm.rotation.z = options.dancing ? Math.cos(Date.now() * 0.01) * 0.5 : 0.1;
        g.add(rightArm);
        
        // Hands
        var leftHand = new THREE.Mesh(
            new THREE.SphereGeometry(0.06, 8, 8),
            new THREE.MeshLambertMaterial({ color: actualSkin })
        );
        leftHand.position.set(torsoWidth/2 + 0.08, 0.68, 0);
        g.add(leftHand);
        
        var rightHand = new THREE.Mesh(
            new THREE.SphereGeometry(0.06, 8, 8),
            new THREE.MeshLambertMaterial({ color: actualSkin })
        );
        rightHand.position.set(-torsoWidth/2 - 0.08, 0.68, 0);
        g.add(rightHand);
        
        // LEGS with pants
        var pantsColors = [0x1a1a2e, 0x2c3e50, 0x34495e, 0x4a4a4a, 0x8b4513, 0x000080];
        var pantsColor = options.pantsColor || pantsColors[Math.floor(Math.random() * pantsColors.length)];
        
        var leftLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.55, 0.15),
            new THREE.MeshLambertMaterial({ color: pantsColor })
        );
        leftLeg.position.set(0.12, 0.4, 0);
        g.add(leftLeg);
        
        var rightLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.55, 0.15),
            new THREE.MeshLambertMaterial({ color: pantsColor })
        );
        rightLeg.position.set(-0.12, 0.4, 0);
        g.add(rightLeg);
        
        // Shoes
        var shoeColors = [0x1a1a1a, 0x4a3728, 0xffffff, 0xff0000, 0x0000ff];
        var shoeColor = shoeColors[Math.floor(Math.random() * shoeColors.length)];
        var leftShoe = new THREE.Mesh(
            new THREE.BoxGeometry(0.14, 0.08, 0.22),
            new THREE.MeshLambertMaterial({ color: shoeColor })
        );
        leftShoe.position.set(0.12, 0.08, 0.03);
        g.add(leftShoe);
        
        var rightShoe = new THREE.Mesh(
            new THREE.BoxGeometry(0.14, 0.08, 0.22),
            new THREE.MeshLambertMaterial({ color: shoeColor })
        );
        rightShoe.position.set(-0.12, 0.08, 0.03);
        g.add(rightShoe);
        
        // HEAD
        var head = new THREE.Mesh(
            new THREE.SphereGeometry(0.22, 16, 16),
            new THREE.MeshLambertMaterial({ color: actualSkin })
        );
        head.position.y = 1.6;
        g.add(head);
        
        // EYES
        var eyeWhite = new THREE.MeshBasicMaterial({ color: 0xffffff });
        var eyeColors = [0x4a3728, 0x1a5f1a, 0x1a1a8f, 0x8f8f8f, 0x5f3a1a, 0x000000];
        var eyeColor = new THREE.MeshBasicMaterial({ color: eyeColors[Math.floor(Math.random() * eyeColors.length)] });
        
        var leftEyeWhite = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 8), eyeWhite);
        leftEyeWhite.position.set(0.08, 1.62, 0.18);
        g.add(leftEyeWhite);
        
        var rightEyeWhite = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 8), eyeWhite);
        rightEyeWhite.position.set(-0.08, 1.62, 0.18);
        g.add(rightEyeWhite);
        
        var leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), eyeColor);
        leftPupil.position.set(0.08, 1.62, 0.21);
        g.add(leftPupil);
        
        var rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), eyeColor);
        rightPupil.position.set(-0.08, 1.62, 0.21);
        g.add(rightPupil);
        
        // HAIR based on style
        var hairMat = new THREE.MeshLambertMaterial({ color: actualHair });
        
        if (hairStyle === 0) {
            // Short hair
            var hair = new THREE.Mesh(new THREE.SphereGeometry(0.24, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
            hair.position.y = 1.68;
            g.add(hair);
        } else if (hairStyle === 1) {
            // Long hair
            var hairTop = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 8, 0, Math.PI * 2, 0, Math.PI * 0.6), hairMat);
            hairTop.position.y = 1.68;
            g.add(hairTop);
            var hairBack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.15), hairMat);
            hairBack.position.set(0, 1.4, -0.12);
            g.add(hairBack);
        } else if (hairStyle === 2) {
            // Ponytail
            var hairTop = new THREE.Mesh(new THREE.SphereGeometry(0.24, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
            hairTop.position.y = 1.68;
            g.add(hairTop);
            var ponytail = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.04, 0.35, 8), hairMat);
            ponytail.position.set(0, 1.55, -0.2);
            ponytail.rotation.x = 0.5;
            g.add(ponytail);
        } else if (hairStyle === 3) {
            // Bald / Very short
            var stubble = new THREE.Mesh(new THREE.SphereGeometry(0.225, 12, 8, 0, Math.PI * 2, 0, Math.PI / 3), hairMat);
            stubble.position.y = 1.72;
            g.add(stubble);
        } else if (hairStyle === 4) {
            // Mohawk / Punk
            var mohawk = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.3), hairMat);
            mohawk.position.set(0, 1.85, 0);
            g.add(mohawk);
        } else if (hairStyle === 5) {
            // Afro
            var afro = new THREE.Mesh(new THREE.SphereGeometry(0.32, 12, 12), hairMat);
            afro.position.y = 1.72;
            g.add(afro);
        }
        
        // ACCESSORIES (random)
        if (Math.random() > 0.7) {
            // Glasses
            var glassesMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
            var leftLens = new THREE.Mesh(new THREE.RingGeometry(0.04, 0.055, 16), glassesMat);
            leftLens.position.set(0.08, 1.62, 0.23);
            g.add(leftLens);
            var rightLens = new THREE.Mesh(new THREE.RingGeometry(0.04, 0.055, 16), glassesMat);
            rightLens.position.set(-0.08, 1.62, 0.23);
            g.add(rightLens);
            var bridge = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.01, 0.01), glassesMat);
            bridge.position.set(0, 1.62, 0.23);
            g.add(bridge);
        }
        
        if (Math.random() > 0.85) {
            // Hat
            var hatColors = [0x1a1a1a, 0x8b4513, 0xff0000, 0x0000ff, 0xffffff];
            var hatMat = new THREE.MeshLambertMaterial({ color: hatColors[Math.floor(Math.random() * hatColors.length)] });
            var hat = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.22, 0.12, 16), hatMat);
            hat.position.y = 1.88;
            g.add(hat);
            var brim = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.28, 0.02, 16), hatMat);
            brim.position.y = 1.83;
            g.add(brim);
        }
        
        // Store body color for animation reference
        g.userData.bodyColor = actualBody;
        g.userData.isFemale = isFemale;
        
        return g;
    }
    
    function createTree(x, z) {
        var g = new THREE.Group();
        var h = 4 + Math.random() * 4;
        g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.4, h, 8), new THREE.MeshLambertMaterial({ color: 0x8b4513 })).translateY(h / 2));
        g.add(new THREE.Mesh(new THREE.SphereGeometry(1.8, 8, 8), new THREE.MeshLambertMaterial({ color: 0x228b22 })).translateY(h + 0.5));
        g.position.set(x, 0, z);
        scene.add(g);
    }
    
    // ============ WORLD CREATION ============
    function initGame() {
        scene = new THREE.Scene();
        
        // IMPROVED SKY - Gradient background
        var skyCanvas = document.createElement('canvas');
        skyCanvas.width = 512;
        skyCanvas.height = 512;
        var skyCtx = skyCanvas.getContext('2d');
        var gradient = skyCtx.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, '#0a0a1a');
        gradient.addColorStop(0.3, '#1a1a3e');
        gradient.addColorStop(0.5, '#2a2a5e');
        gradient.addColorStop(0.7, '#3a3a7e');
        gradient.addColorStop(1, '#1a1a2e');
        skyCtx.fillStyle = gradient;
        skyCtx.fillRect(0, 0, 512, 512);
        // Add stars
        skyCtx.fillStyle = '#ffffff';
        for (var star = 0; star < 200; star++) {
            var sx = Math.random() * 512;
            var sy = Math.random() * 300;
            var sr = Math.random() * 1.5;
            skyCtx.beginPath();
            skyCtx.arc(sx, sy, sr, 0, Math.PI * 2);
            skyCtx.fill();
        }
        var skyTexture = new THREE.CanvasTexture(skyCanvas);
        scene.background = skyTexture;
        
        scene.fog = new THREE.FogExp2(0x1a1a2e, 0.0008);
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        initControls();
        
        // IMPROVED GROUND - Textured with grid pattern
        var groundCanvas = document.createElement('canvas');
        groundCanvas.width = 512;
        groundCanvas.height = 512;
        var gCtx = groundCanvas.getContext('2d');
        gCtx.fillStyle = '#1a2a1a';
        gCtx.fillRect(0, 0, 512, 512);
        // Add subtle grass texture
        for (var gx = 0; gx < 512; gx += 4) {
            for (var gy = 0; gy < 512; gy += 4) {
                var shade = 20 + Math.random() * 20;
                gCtx.fillStyle = 'rgb(' + shade + ',' + (shade + 20) + ',' + shade + ')';
                gCtx.fillRect(gx, gy, 3, 3);
            }
        }
        var groundTex = new THREE.CanvasTexture(groundCanvas);
        groundTex.wrapS = THREE.RepeatWrapping;
        groundTex.wrapT = THREE.RepeatWrapping;
        groundTex.repeat.set(50, 50);
        
        var ground = new THREE.Mesh(
            new THREE.PlaneGeometry(2400, 2400, 50, 50), 
            new THREE.MeshStandardMaterial({ 
                map: groundTex,
                roughness: 0.9,
                metalness: 0.1
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // CLOUDS
        createClouds();
        
        // MOON
        var moon = new THREE.Mesh(
            new THREE.SphereGeometry(30, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xffffee })
        );
        moon.position.set(500, 400, -800);
        scene.add(moon);
        var moonGlow = new THREE.PointLight(0xaabbcc, 0.3, 1500);
        moonGlow.position.copy(moon.position);
        scene.add(moonGlow);
        
        createRoads();
        createCrosswalks();
        createParks();
        createFountains();
        createStreetLamps();
        createBuildings();
        createSkyscrapers();
        createCathedral();
        createStadium();
        createDisco();
        createGrandRestaurant();
        createCathedral2();
        createTechHub();
        createSkyTower();
        createLEDSigns();
        createNPCs();
        createPedestrians();
        createCars();
        createPoliceCars();
        createBuses();
        createAirplanes();
        createTrees();
        createBirds();
        
        // IMPROVED LIGHTING
        scene.add(new THREE.AmbientLight(0x303050, 0.5));
        
        var sun = new THREE.DirectionalLight(0xffeedd, 0.6);
        sun.position.set(300, 400, 200);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 1500;
        sun.shadow.camera.left = -500;
        sun.shadow.camera.right = 500;
        sun.shadow.camera.top = 500;
        sun.shadow.camera.bottom = -500;
        scene.add(sun);
        
        scene.add(new THREE.HemisphereLight(0x6688cc, 0x2a3a2a, 0.5));
        
        // Atmospheric rim light
        var rimLight = new THREE.DirectionalLight(0x4488ff, 0.2);
        rimLight.position.set(-200, 100, -300);
        scene.add(rimLight);
        
        animate();
    }
    
    // CLOUDS
    function createClouds() {
        for (var c = 0; c < 25; c++) {
            var cloudGroup = new THREE.Group();
            var cloudMat = new THREE.MeshLambertMaterial({ 
                color: 0x444466, 
                transparent: true, 
                opacity: 0.6 
            });
            
            // Multiple spheres for fluffy cloud
            for (var p = 0; p < 5 + Math.random() * 5; p++) {
                var puff = new THREE.Mesh(
                    new THREE.SphereGeometry(15 + Math.random() * 20, 8, 8),
                    cloudMat
                );
                puff.position.set(
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 30
                );
                cloudGroup.add(puff);
            }
            
            cloudGroup.position.set(
                (Math.random() - 0.5) * 2000,
                150 + Math.random() * 100,
                (Math.random() - 0.5) * 2000
            );
            cloudGroup.userData.speed = 0.05 + Math.random() * 0.1;
            scene.add(cloudGroup);
        }
    }
    
    // FOUNTAINS in parks
    function createFountains() {
        var fountainPositions = [
            { x: 0, z: 0 },
            { x: -50, z: -50 },
            { x: 50, z: 50 }
        ];
        
        fountainPositions.forEach(function(pos) {
            var fountain = new THREE.Group();
            
            // Base pool
            var pool = new THREE.Mesh(
                new THREE.CylinderGeometry(4, 5, 1, 24),
                new THREE.MeshStandardMaterial({ color: 0x666677, roughness: 0.3, metalness: 0.5 })
            );
            pool.position.y = 0.5;
            fountain.add(pool);
            
            // Water surface
            var water = new THREE.Mesh(
                new THREE.CylinderGeometry(3.8, 3.8, 0.1, 24),
                new THREE.MeshStandardMaterial({ 
                    color: 0x4488aa, 
                    transparent: true, 
                    opacity: 0.7,
                    roughness: 0.1,
                    metalness: 0.8
                })
            );
            water.position.y = 0.9;
            fountain.add(water);
            
            // Central column
            var column = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.8, 3, 16),
                new THREE.MeshStandardMaterial({ color: 0x888899, roughness: 0.4, metalness: 0.6 })
            );
            column.position.y = 2;
            fountain.add(column);
            
            // Top bowl
            var bowl = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1, 0.5, 16),
                new THREE.MeshStandardMaterial({ color: 0x888899, roughness: 0.4, metalness: 0.6 })
            );
            bowl.position.y = 3.5;
            fountain.add(bowl);
            
            // Water spout (simulated with particles)
            var spoutGeom = new THREE.CylinderGeometry(0.1, 0.3, 2, 8);
            var spoutMat = new THREE.MeshBasicMaterial({ 
                color: 0x88ccff, 
                transparent: true, 
                opacity: 0.5 
            });
            var spout = new THREE.Mesh(spoutGeom, spoutMat);
            spout.position.y = 4.5;
            fountain.add(spout);
            
            // Light in fountain
            var fountainLight = new THREE.PointLight(0x4488ff, 0.5, 15);
            fountainLight.position.y = 1;
            fountain.add(fountainLight);
            
            fountain.position.set(pos.x, 0, pos.z);
            scene.add(fountain);
        });
    }
    
    // DETAILED STREET LAMPS
    function createStreetLamps() {
        var lampPositions = [];
        
        // Generate lamp positions along roads
        for (var rx = -600; rx <= 600; rx += 50) {
            lampPositions.push({ x: rx, z: 15 });
            lampPositions.push({ x: rx, z: -15 });
            lampPositions.push({ x: 15, z: rx });
            lampPositions.push({ x: -15, z: rx });
        }
        
        lampPositions.forEach(function(pos, idx) {
            if (Math.random() > 0.4) return; // Not every position gets a lamp
            
            var lamp = new THREE.Group();
            
            // Pole
            var pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.2, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.7 })
            );
            pole.position.y = 4;
            lamp.add(pole);
            
            // Decorative base
            var base = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.5, 0.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.7 })
            );
            base.position.y = 0.25;
            lamp.add(base);
            
            // Arm
            var arm = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.1, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.7 })
            );
            arm.position.set(1, 7.8, 0);
            lamp.add(arm);
            
            // Lamp housing
            var housing = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.5, 0.4),
                new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3, metalness: 0.8 })
            );
            housing.position.set(1.8, 7.6, 0);
            lamp.add(housing);
            
            // Light bulb
            var bulb = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffdd88 })
            );
            bulb.position.set(1.8, 7.35, 0);
            lamp.add(bulb);
            
            // Actual light
            var light = new THREE.PointLight(0xffaa55, 0.6, 25);
            light.position.set(1.8, 7.3, 0);
            lamp.add(light);
            
            // Ground light cone effect
            var cone = new THREE.Mesh(
                new THREE.ConeGeometry(3, 6, 16, 1, true),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffdd88, 
                    transparent: true, 
                    opacity: 0.03,
                    side: THREE.DoubleSide
                })
            );
            cone.position.set(1.8, 4, 0);
            lamp.add(cone);
            
            lamp.position.set(pos.x, 0, pos.z);
            lamp.rotation.y = Math.random() * Math.PI * 2;
            scene.add(lamp);
        });
    }
    
    // BIRDS flying around
    function createBirds() {
        for (var b = 0; b < 20; b++) {
            var bird = new THREE.Group();
            
            // Body
            var body = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0x222222 })
            );
            bird.add(body);
            
            // Wings
            var wingMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            var leftWing = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.05, 0.3), wingMat);
            leftWing.position.set(0, 0, 0.4);
            leftWing.name = 'leftWing';
            bird.add(leftWing);
            
            var rightWing = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.05, 0.3), wingMat);
            rightWing.position.set(0, 0, -0.4);
            rightWing.name = 'rightWing';
            bird.add(rightWing);
            
            // Beak
            var beak = new THREE.Mesh(
                new THREE.ConeGeometry(0.1, 0.3, 6),
                new THREE.MeshLambertMaterial({ color: 0xffaa00 })
            );
            beak.rotation.x = Math.PI / 2;
            beak.position.x = 0.4;
            bird.add(beak);
            
            bird.position.set(
                (Math.random() - 0.5) * 1000,
                30 + Math.random() * 50,
                (Math.random() - 0.5) * 1000
            );
            
            bird.userData = {
                speedX: (Math.random() - 0.5) * 0.5,
                speedZ: (Math.random() - 0.5) * 0.5,
                flapPhase: Math.random() * Math.PI * 2
            };
            
            scene.add(bird);
            pedestrians.push(bird); // Reuse pedestrians array for animation
        }
    }
    
    function initControls() {
        var isDragging = false;
        var lastMouseX = 0;
        var lastMouseY = 0;
        
        // Mouse down - start dragging
        renderer.domElement.addEventListener('mousedown', function(e) {
            if (gameStarted && !isInArcade && !isOnBus) {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                renderer.domElement.style.cursor = 'grabbing';
            }
        });
        
        // Mouse up - stop dragging
        document.addEventListener('mouseup', function(e) {
            isDragging = false;
            if (renderer && renderer.domElement) {
                renderer.domElement.style.cursor = 'grab';
            }
        });
        
        // Mouse move - look around when dragging
        document.addEventListener('mousemove', function(e) {
            if (!isDragging || !gameStarted) return;
            
            var deltaX = e.clientX - lastMouseX;
            var deltaY = e.clientY - lastMouseY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            if (isInside && !isInArcade) {
                // Interior first person view
                interiorTargetRot.y -= deltaX * 0.008;
                interiorTargetRot.x -= deltaY * 0.008;
                interiorTargetRot.x = Math.max(-1.2, Math.min(1.2, interiorTargetRot.x));
            } else if (!isInside && !isOnBus && !isInArcade) {
                // Outdoor first person view - IMMEDIATELY change direction
                targetRot.y -= deltaX * 0.008;
                targetRot.x -= deltaY * 0.008;
                targetRot.x = Math.max(-1.4, Math.min(1.4, targetRot.x));
            }
        });
        
        // Prevent context menu on right click
        renderer.domElement.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });
        
        // Set initial cursor
        renderer.domElement.style.cursor = 'grab';
    }
    
    function createRoads() {
        var roadMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
        var lineMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        [-400, -300, -200, -100, 0, 100, 200, 300, 400].forEach(function(pos) {
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(1200, 0.1, 16), roadMat).translateZ(pos));
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(1800, 0.12, 0.5), lineMat).translateY(0.1).translateZ(pos));
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(16, 0.1, 1800), roadMat).translateX(pos));
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.12, 1800), lineMat).translateY(0.1).translateX(pos));
        });
        // Extended roads for larger city
        [-500, -600, 500, 600].forEach(function(pos) {
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(1800, 0.1, 16), roadMat).translateZ(pos));
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(1800, 0.12, 0.5), lineMat).translateY(0.1).translateZ(pos));
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(16, 0.1, 1800), roadMat).translateX(pos));
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.12, 1800), lineMat).translateY(0.1).translateX(pos));
        });
    }
    
    function createCrosswalks() {
        var whiteMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        [-600, -500, -400, -300, -200, -100, 0, 100, 200, 300, 400, 500, 600].forEach(function(rx) {
            [-600, -500, -400, -300, -200, -100, 0, 100, 200, 300, 400, 500, 600].forEach(function(rz) {
                for (var s = -5; s <= 5; s += 1.3) {
                    scene.add(new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.12, 0.7), whiteMat).translateX(rx + 13).translateZ(rz + s).translateY(0.08));
                    scene.add(new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.12, 0.7), whiteMat).translateX(rx - 13).translateZ(rz + s).translateY(0.08));
                }
            });
        });
    }
    
    function createParks() {
        var parkPositions = [
            { x: -50, z: -50 }, { x: 50, z: -50 }, { x: -50, z: 50 }, { x: 50, z: 50 }, 
            { x: -150, z: 50 }, { x: 150, z: 50 },
            { x: -350, z: 150 }, { x: 350, z: 150 },
            { x: -550, z: 50 }, { x: 550, z: -50 }
        ];
        parkPositions.forEach(function(p) {
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(45, 0.12, 45), new THREE.MeshLambertMaterial({ color: 0x228822 })).translateX(p.x).translateZ(p.z).translateY(0.05));
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 38), new THREE.MeshLambertMaterial({ color: 0xccaa88 })).translateX(p.x).translateZ(p.z).translateY(0.08));
            scene.add(new THREE.Mesh(new THREE.CylinderGeometry(2, 2.4, 0.7, 16), new THREE.MeshLambertMaterial({ color: 0x888888 })).translateX(p.x).translateZ(p.z).translateY(0.35));
            for (var t = 0; t < 5; t++) createTree(p.x + (Math.random() - 0.5) * 35, p.z + (Math.random() - 0.5) * 35);
        });
    }
    
    function createBuildings() {
        var interiorKeys = Object.keys(missions).filter(function(k) { return missions[k].type === 'interior' || missions[k].type === 'arcade'; });
        var positions = [
            { x: -250, z: -250 }, { x: -150, z: -250 }, { x: -50, z: -250 }, { x: 50, z: -250 }, { x: 150, z: -250 }, { x: 250, z: -250 },
            { x: -250, z: -150 }, { x: 250, z: -150 },
            { x: -250, z: 150 }, { x: 250, z: 150 },
            { x: -250, z: 250 }, { x: -150, z: 250 }, { x: 0, z: 250 },
            { x: 350, z: -150 }, { x: -350, z: -150 }, { x: 450, z: 250 }
        ];
        
        interiorKeys.forEach(function(key, i) {
            if (i < positions.length) createBuilding(positions[i].x, positions[i].z, key);
        });
    }
    
    function createBuilding(x, z, key) {
        var m = missions[key];
        var g = new THREE.Group();
        var colors = { clothing: 0xec4899, electronics: 0x0ea5e9, pharmacy: 0x06b6d4, restaurant: 0xb91c1c, bank: 0x1e40af, cafe: 0x78350f, bookstore: 0x92400e, gym: 0xdc2626, hotel: 0xd97706, gallery: 0x7c3aed, supermarket: 0x059669, arcade: 0xff00ff };
        
        var height = m.type === 'arcade' ? 12 : 14 + Math.random() * 10;
        var buildingColor = colors[m.buildingType] || (m.type === 'arcade' ? 0xff00ff : 0x666666);
        
        // Main building with better material
        var mainMat = new THREE.MeshStandardMaterial({ 
            color: buildingColor, 
            roughness: 0.7, 
            metalness: 0.2 
        });
        var main = new THREE.Mesh(new THREE.BoxGeometry(20, height, 18), mainMat);
        main.position.y = height / 2;
        main.castShadow = true;
        main.receiveShadow = true;
        g.add(main);
        
        // Architectural details - pilasters on corners
        var pilasterMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.5 });
        [[-10, 9], [10, 9], [-10, -9], [10, -9]].forEach(function(pos) {
            var pilaster = new THREE.Mesh(new THREE.BoxGeometry(1, height, 1), pilasterMat);
            pilaster.position.set(pos[0], height/2, pos[1]);
            g.add(pilaster);
        });
        
        // Detailed windows with frames and interior glow
        for (var r = 0; r < Math.floor(height / 4); r++) {
            for (var w = 0; w < 4; w++) {
                var winGroup = new THREE.Group();
                
                // Window frame
                var frameMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5 });
                winGroup.add(new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.4, 0.05), frameMat));
                
                // Glass with reflection
                var glassMat = new THREE.MeshStandardMaterial({ 
                    color: m.type === 'arcade' ? 0xff00ff : 0x88bbdd,
                    transparent: true,
                    opacity: 0.7,
                    metalness: 0.9,
                    roughness: 0.1
                });
                winGroup.add(new THREE.Mesh(new THREE.BoxGeometry(2.8, 2, 0.03), glassMat).translateZ(0.03));
                
                // Interior light (random on/off)
                if (Math.random() > 0.3) {
                    var interiorLight = new THREE.Mesh(
                        new THREE.BoxGeometry(2.6, 1.8, 0.02),
                        new THREE.MeshBasicMaterial({ color: 0xffffaa })
                    );
                    interiorLight.position.z = -0.05;
                    winGroup.add(interiorLight);
                }
                
                winGroup.position.set(-6 + w * 4, 3 + r * 4, 9.1);
                g.add(winGroup);
            }
        }
        
        // Entrance with awning
        var doorFrame = new THREE.Mesh(
            new THREE.BoxGeometry(4.2, 5.5, 0.3), 
            new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.8 })
        );
        doorFrame.position.set(0, 2.75, 9.15);
        g.add(doorFrame);
        
        // Glass door
        var glassDoor = new THREE.Mesh(
            new THREE.BoxGeometry(3.6, 4.8, 0.1),
            new THREE.MeshStandardMaterial({ color: 0x88aacc, transparent: true, opacity: 0.5, metalness: 0.8 })
        );
        glassDoor.position.set(0, 2.5, 9.2);
        g.add(glassDoor);
        
        // Awning
        var awningMat = new THREE.MeshLambertMaterial({ color: buildingColor });
        var awning = new THREE.Mesh(new THREE.BoxGeometry(6, 0.2, 2.5), awningMat);
        awning.position.set(0, 5.5, 10);
        g.add(awning);
        
        // Awning supports
        [[-2.5, 10.5], [2.5, 10.5]].forEach(function(pos) {
            var support = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 1.5),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            support.position.set(pos[0], 4.8, pos[1]);
            support.rotation.x = Math.PI / 6;
            g.add(support);
        });
        
        // Illuminated sign with glow
        var signCanvas = document.createElement('canvas');
        signCanvas.width = 256;
        signCanvas.height = 48;
        var ctx = signCanvas.getContext('2d');
        ctx.fillStyle = m.type === 'arcade' ? '#220033' : '#111';
        ctx.fillRect(0, 0, 256, 48);
        ctx.fillStyle = m.type === 'arcade' ? '#ff00ff' : '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(m.buildingName, 128, 30);
        
        var signMesh = new THREE.Mesh(
            new THREE.BoxGeometry(14, 2.8, 0.3), 
            new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(signCanvas) })
        );
        signMesh.position.set(0, height - 2.5, 9.2);
        g.add(signMesh);
        
        // Sign glow
        var signLight = new THREE.PointLight(buildingColor, 0.5, 10);
        signLight.position.set(0, height - 2.5, 11);
        g.add(signLight);
        
        // Rooftop details
        var roofAC = new THREE.Mesh(
            new THREE.BoxGeometry(4, 2, 3),
            new THREE.MeshLambertMaterial({ color: 0x666666 })
        );
        roofAC.position.set(5, height + 1, 0);
        g.add(roofAC);
        
        if (m.type === 'arcade') {
            // Neon lights for arcade
            g.add(new THREE.PointLight(0xff00ff, 1.5, 20).translateX(-8).translateY(5).translateZ(10));
            g.add(new THREE.PointLight(0x00ffff, 1.5, 20).translateX(8).translateY(5).translateZ(10));
            
            // Animated neon strips
            var neonColors = [0xff00ff, 0x00ffff, 0xffff00];
            for (var n = 0; n < 3; n++) {
                var neon = new THREE.Mesh(
                    new THREE.BoxGeometry(18, 0.3, 0.1),
                    new THREE.MeshBasicMaterial({ color: neonColors[n] })
                );
                neon.position.set(0, 1 + n * 3, 9.15);
                g.add(neon);
            }
        }
        
        // Entrance mat
        var mat = new THREE.Mesh(
            new THREE.BoxGeometry(3, 0.05, 1.5),
            new THREE.MeshLambertMaterial({ color: 0x333333 })
        );
        mat.position.set(0, 0.025, 11);
        g.add(mat);
        
        g.position.set(x, 0, z);
        scene.add(g);
        
        m.x = x;
        m.z = z + 14;
        buildingEntrances.push({ key: key, x: x, z: z + 14 });
    }
    
    function createSkyscrapers() {
        var skyscraperData = [
            { x: 350, z: -350, h: 100, c: 0x334455, key: 'ceo' },
            { x: 400, z: -300, h: 85, c: 0x445566 },
            { x: 300, z: -400, h: 75, c: 0x2a3a4a },
            { x: -350, z: -350, h: 90, c: 0x334466, key: 'aiResearcher' },
            { x: -400, z: -300, h: 70, c: 0x445577 },
            { x: -300, z: -400, h: 65, c: 0x223355 },
            { x: 350, z: 350, h: 80, c: 0x553344 },
            { x: -350, z: 350, h: 60, c: 0x443322 },
            { x: 450, z: 0, h: 55, c: 0x3a3a4a },
            { x: -450, z: 0, h: 50, c: 0x4a3a3a }
        ];
        
        skyscraperData.forEach(function(data) {
            var g = new THREE.Group();
            
            // Modern glass curtain wall material
            var glassMat = new THREE.MeshStandardMaterial({ 
                color: data.c, 
                roughness: 0.1, 
                metalness: 0.9,
                transparent: true,
                opacity: 0.85
            });
            
            // Main tower
            var tower = new THREE.Mesh(new THREE.BoxGeometry(30, data.h, 25), glassMat);
            tower.position.y = data.h / 2;
            tower.castShadow = true;
            tower.receiveShadow = true;
            g.add(tower);
            
            // Mullions (vertical window dividers)
            var mullionMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7 });
            for (var mx = -12; mx <= 12; mx += 4) {
                var mullion = new THREE.Mesh(new THREE.BoxGeometry(0.3, data.h, 0.3), mullionMat);
                mullion.position.set(mx, data.h / 2, 12.7);
                g.add(mullion);
            }
            
            // Horizontal floor lines
            for (var floor = 0; floor < Math.floor(data.h / 5); floor++) {
                var floorLine = new THREE.Mesh(
                    new THREE.BoxGeometry(30.5, 0.2, 0.3),
                    mullionMat
                );
                floorLine.position.set(0, 2 + floor * 5, 12.7);
                g.add(floorLine);
                
                // Windows with interior lights
                for (var w = 0; w < 5; w++) {
                    var winGroup = new THREE.Group();
                    
                    // Glass panel
                    var glass = new THREE.Mesh(
                        new THREE.BoxGeometry(3.2, 4, 0.1),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x6699bb,
                            transparent: true,
                            opacity: 0.6,
                            metalness: 0.95,
                            roughness: 0.05
                        })
                    );
                    winGroup.add(glass);
                    
                    // Interior light (randomly lit)
                    if (Math.random() > 0.25) {
                        var lightColor = Math.random() > 0.8 ? 0xffffcc : 0xffffaa;
                        var interiorGlow = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 3.5, 0.05),
                            new THREE.MeshBasicMaterial({ color: lightColor })
                        );
                        interiorGlow.position.z = -0.1;
                        winGroup.add(interiorGlow);
                    }
                    
                    winGroup.position.set(-10 + w * 4.8, 4 + floor * 5, 12.65);
                    g.add(winGroup);
                }
            }
            
            // Lobby (ground floor)
            var lobbyMat = new THREE.MeshStandardMaterial({ 
                color: 0x888888, 
                metalness: 0.3,
                roughness: 0.7
            });
            var lobby = new THREE.Mesh(new THREE.BoxGeometry(32, 8, 27), lobbyMat);
            lobby.position.y = 4;
            g.add(lobby);
            
            // Lobby entrance
            var entranceGlass = new THREE.Mesh(
                new THREE.BoxGeometry(12, 6, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x88aacc, transparent: true, opacity: 0.4 })
            );
            entranceGlass.position.set(0, 3.5, 13.5);
            g.add(entranceGlass);
            
            // Revolving door effect
            var revDoor = new THREE.Mesh(
                new THREE.BoxGeometry(3, 5, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            revDoor.position.set(0, 3, 13.6);
            g.add(revDoor);
            
            // Penthouse/mechanical floor
            var penthouse = new THREE.Mesh(
                new THREE.BoxGeometry(20, 10, 18),
                new THREE.MeshStandardMaterial({ color: data.c - 0x111111, roughness: 0.2, metalness: 0.8 })
            );
            penthouse.position.y = data.h + 5;
            g.add(penthouse);
            
            // Helipad on roof
            if (data.h > 80) {
                var helipad = new THREE.Mesh(
                    new THREE.CylinderGeometry(6, 6, 0.3, 32),
                    new THREE.MeshStandardMaterial({ color: 0x333333 })
                );
                helipad.position.y = data.h + 10.2;
                g.add(helipad);
                
                // H marking
                var hCanvas = document.createElement('canvas');
                hCanvas.width = 64;
                hCanvas.height = 64;
                var hCtx = hCanvas.getContext('2d');
                hCtx.fillStyle = '#333';
                hCtx.fillRect(0, 0, 64, 64);
                hCtx.fillStyle = '#fff';
                hCtx.font = 'bold 48px Arial';
                hCtx.textAlign = 'center';
                hCtx.fillText('H', 32, 48);
                var hMark = new THREE.Mesh(
                    new THREE.CylinderGeometry(5, 5, 0.05, 32),
                    new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(hCanvas) })
                );
                hMark.position.y = data.h + 10.35;
                g.add(hMark);
            }
            
            // Antenna for tall buildings
            if (data.h > 60) {
                var antennaBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(1, 1.5, 5),
                    new THREE.MeshStandardMaterial({ color: 0x666666 })
                );
                antennaBase.position.y = data.h + 12;
                g.add(antennaBase);
                
                var antenna = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.5, 15),
                    new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                );
                antenna.position.y = data.h + 22;
                g.add(antenna);
                
                // Red warning light
                var warningLight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                warningLight.position.y = data.h + 30;
                g.add(warningLight);
                
                var antennaLight = new THREE.PointLight(0xff0000, 1, 40);
                antennaLight.position.y = data.h + 30;
                g.add(antennaLight);
            }
            
            // Corporate logo/name plate
            if (data.key) {
                var logoCanvas = document.createElement('canvas');
                logoCanvas.width = 256;
                logoCanvas.height = 64;
                var logoCtx = logoCanvas.getContext('2d');
                logoCtx.fillStyle = '#111';
                logoCtx.fillRect(0, 0, 256, 64);
                logoCtx.fillStyle = '#88aaff';
                logoCtx.font = 'bold 20px Arial';
                logoCtx.textAlign = 'center';
                logoCtx.fillText(data.key === 'ceo' ? 'METROPOLIS CORP' : 'TECH INNOVATIONS', 128, 40);
                
                var logoPlate = new THREE.Mesh(
                    new THREE.BoxGeometry(15, 4, 0.3),
                    new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(logoCanvas) })
                );
                logoPlate.position.set(0, 10, 13.7);
                g.add(logoPlate);
            }
            
            g.position.set(data.x, 0, data.z);
            scene.add(g);
            
            if (data.key && missions[data.key]) {
                missions[data.key].x = data.x;
                missions[data.key].z = data.z + 18;
                skyscraperEntrances.push({ key: data.key, x: data.x, z: data.z + 18 });
            }
        });
    }
    
    function createCathedral() {
        var g = new THREE.Group();
        var stoneMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
        
        g.add(new THREE.Mesh(new THREE.BoxGeometry(35, 30, 60), stoneMat).translateY(15));
        
        g.add(new THREE.Mesh(new THREE.BoxGeometry(10, 50, 10), stoneMat).translateY(25).translateX(-15).translateZ(-20));
        g.add(new THREE.Mesh(new THREE.BoxGeometry(10, 50, 10), stoneMat).translateY(25).translateX(15).translateZ(-20));
        
        var spireMat = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
        g.add(new THREE.Mesh(new THREE.ConeGeometry(5, 18), spireMat).translateY(59).translateX(-15).translateZ(-20));
        g.add(new THREE.Mesh(new THREE.ConeGeometry(5, 18), spireMat).translateY(59).translateX(15).translateZ(-20));
        g.add(new THREE.Mesh(new THREE.ConeGeometry(3, 12), spireMat).translateY(36).translateZ(10));
        
        g.add(new THREE.Mesh(new THREE.CircleGeometry(5, 32), new THREE.MeshBasicMaterial({ color: 0xff4488 })).translateY(22).translateZ(-30.1));
        
        var glassMat = new THREE.MeshBasicMaterial({ color: 0x4488ff });
        for (var i = -2; i <= 2; i++) {
            g.add(new THREE.Mesh(new THREE.BoxGeometry(3, 10, 0.2), glassMat).translateY(15).translateZ(i * 10).translateX(17.6));
            g.add(new THREE.Mesh(new THREE.BoxGeometry(3, 10, 0.2), glassMat).translateY(15).translateZ(i * 10).translateX(-17.6));
        }
        
        g.add(new THREE.Mesh(new THREE.BoxGeometry(6, 10, 2), new THREE.MeshLambertMaterial({ color: 0x4a3a2a })).translateY(5).translateZ(-30));
        
        g.position.set(-450, 0, 450);
        scene.add(g);
        
        missions.curator.x = -450;
        missions.curator.z = 420;
        buildingEntrances.push({ key: 'curator', x: -450, z: 420 });
    }
    
    // ============ STADIUM ============
    function createStadium() {
        var g = new THREE.Group();
        var concreteMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
        var seatMat = new THREE.MeshLambertMaterial({ color: 0x1e40af });
        var grassMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
        
        // Main structure - oval bowl
        for (var angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
            var stand = new THREE.Mesh(new THREE.BoxGeometry(25, 20, 15), concreteMat);
            stand.position.set(Math.cos(angle) * 55, 10, Math.sin(angle) * 40);
            stand.rotation.y = -angle + Math.PI / 2;
            g.add(stand);
            // Seats
            for (var row = 0; row < 4; row++) {
                var seats = new THREE.Mesh(new THREE.BoxGeometry(22, 1, 3), seatMat);
                seats.position.set(Math.cos(angle) * (50 - row * 4), 5 + row * 3.5, Math.sin(angle) * (36 - row * 3));
                seats.rotation.y = -angle + Math.PI / 2;
                g.add(seats);
            }
        }
        
        // Field
        g.add(new THREE.Mesh(new THREE.BoxGeometry(90, 0.5, 60), grassMat).translateY(0.25));
        // Field lines
        var lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        g.add(new THREE.Mesh(new THREE.BoxGeometry(88, 0.6, 0.5), lineMat).translateY(0.55));
        g.add(new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 58), lineMat).translateY(0.55));
        g.add(new THREE.Mesh(new THREE.CircleGeometry(9, 32), lineMat).translateY(0.55).rotateX(-Math.PI/2));
        
        // Goals
        var goalMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        for (var gx = -1; gx <= 1; gx += 2) {
            var goal = new THREE.Group();
            goal.add(new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 8), goalMat).translateY(4).translateX(-3.5));
            goal.add(new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 8), goalMat).translateY(4).translateX(3.5));
            goal.add(new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 7.2), goalMat).translateY(8).rotateZ(Math.PI/2));
            goal.position.set(gx * 42, 0, 0);
            g.add(goal);
        }
        
        // Floodlights
        for (var fl = 0; fl < 4; fl++) {
            var floodlight = new THREE.Group();
            floodlight.add(new THREE.Mesh(new THREE.CylinderGeometry(1, 1.5, 35), new THREE.MeshLambertMaterial({ color: 0x555555 })).translateY(17.5));
            floodlight.add(new THREE.Mesh(new THREE.BoxGeometry(8, 4, 2), new THREE.MeshLambertMaterial({ color: 0x333333 })).translateY(37));
            var light = new THREE.PointLight(0xffffee, 0.8, 100);
            light.position.y = 38;
            floodlight.add(light);
            var angles = [Math.PI/4, 3*Math.PI/4, 5*Math.PI/4, 7*Math.PI/4];
            floodlight.position.set(Math.cos(angles[fl]) * 75, 0, Math.sin(angles[fl]) * 55);
            g.add(floodlight);
        }
        
        // Entrance
        var entrance = new THREE.Mesh(new THREE.BoxGeometry(15, 8, 5), new THREE.MeshLambertMaterial({ color: 0x444444 }));
        entrance.position.set(0, 4, 60);
        g.add(entrance);
        
        g.position.set(550, 0, 0);
        scene.add(g);
        
        missions.stadium.x = 550;
        missions.stadium.z = 65;
        buildingEntrances.push({ key: 'stadium', x: 550, z: 65 });
    }
    
    // ============ DISCO / NIGHTCLUB ============
    function createDisco() {
        var g = new THREE.Group();
        var darkMat = new THREE.MeshLambertMaterial({ color: 0x1a1a2e });
        
        // Main building - modern angular design
        g.add(new THREE.Mesh(new THREE.BoxGeometry(50, 15, 40), darkMat).translateY(7.5));
        
        // Neon strips on exterior
        var neonColors = [0xff0066, 0x00ffff, 0xffff00, 0xff00ff];
        for (var i = 0; i < 4; i++) {
            var neonStrip = new THREE.Mesh(
                new THREE.BoxGeometry(48, 0.5, 0.3),
                new THREE.MeshBasicMaterial({ color: neonColors[i] })
            );
            neonStrip.position.set(0, 3 + i * 3.5, 20.2);
            g.add(neonStrip);
            
            var neonLight = new THREE.PointLight(neonColors[i], 0.5, 15);
            neonLight.position.set(0, 3 + i * 3.5, 22);
            g.add(neonLight);
        }
        
        // Big sign "NEON NIGHTS"
        var signCanvas = document.createElement('canvas');
        signCanvas.width = 512;
        signCanvas.height = 128;
        var ctx = signCanvas.getContext('2d');
        ctx.fillStyle = '#0a0a1a';
        ctx.fillRect(0, 0, 512, 128);
        ctx.fillStyle = '#ff00ff';
        ctx.font = 'bold 60px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('NEON NIGHTS', 256, 80);
        var signTex = new THREE.CanvasTexture(signCanvas);
        g.add(new THREE.Mesh(
            new THREE.BoxGeometry(25, 6, 0.5),
            new THREE.MeshBasicMaterial({ map: signTex })
        ).translateY(18).translateZ(20.3));
        
        // Disco ball on top
        var discoBall = new THREE.Mesh(
            new THREE.SphereGeometry(3, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 1, roughness: 0.1 })
        );
        discoBall.position.set(0, 20, 0);
        g.add(discoBall);
        
        // Rotating spotlight effect
        var spotRed = new THREE.SpotLight(0xff0066, 1, 50, Math.PI/6);
        spotRed.position.set(0, 18, 0);
        g.add(spotRed);
        var spotBlue = new THREE.SpotLight(0x00ffff, 1, 50, Math.PI/6);
        spotBlue.position.set(0, 18, 0);
        g.add(spotBlue);
        
        // Entrance with red carpet
        g.add(new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, 15), new THREE.MeshLambertMaterial({ color: 0x8b0000 })).translateY(0.1).translateZ(27));
        g.add(new THREE.Mesh(new THREE.BoxGeometry(10, 6, 4), new THREE.MeshLambertMaterial({ color: 0x2a2a3a })).translateY(3).translateZ(22));
        
        // Bouncers
        var bouncer1 = createPerson(0x1a1a1a, 0x8d5524, 0x1a1a1a, { hairStyle: 3 });
        bouncer1.position.set(-4, 0, 32);
        g.add(bouncer1);
        var bouncer2 = createPerson(0x1a1a1a, 0xd4a574, 0x1a1a1a, { hairStyle: 3 });
        bouncer2.position.set(4, 0, 32);
        g.add(bouncer2);
        
        g.position.set(-550, 0, -150);
        scene.add(g);
        
        missions.disco.x = -550;
        missions.disco.z = -115;
        buildingEntrances.push({ key: 'disco', x: -550, z: -115 });
    }
    
    // ============ GRAND RESTAURANT ============
    function createGrandRestaurant() {
        var g = new THREE.Group();
        var wallMat = new THREE.MeshLambertMaterial({ color: 0xfaf0e6 });
        var roofMat = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
        
        // Main building - elegant classical style
        g.add(new THREE.Mesh(new THREE.BoxGeometry(60, 12, 45), wallMat).translateY(6));
        
        // Roof
        g.add(new THREE.Mesh(new THREE.BoxGeometry(64, 2, 49), roofMat).translateY(13));
        
        // Columns at entrance
        var columnMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        for (var col = -2; col <= 2; col++) {
            var column = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 10, 16), columnMat);
            column.position.set(col * 6, 5, 23);
            g.add(column);
            // Column capital
            g.add(new THREE.Mesh(new THREE.BoxGeometry(2.2, 1, 2.2), columnMat).translateY(10.5).translateX(col * 6).translateZ(23));
        }
        
        // Portico roof
        g.add(new THREE.Mesh(new THREE.BoxGeometry(30, 1.5, 8), roofMat).translateY(11.5).translateZ(23));
        
        // Windows with golden frames
        var windowMat = new THREE.MeshBasicMaterial({ color: 0xffffcc, transparent: true, opacity: 0.7 });
        var frameMat = new THREE.MeshLambertMaterial({ color: 0xd4af37 });
        for (var wx = -20; wx <= 20; wx += 10) {
            g.add(new THREE.Mesh(new THREE.BoxGeometry(4, 6, 0.2), windowMat).translateY(6).translateX(wx).translateZ(22.6));
            g.add(new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.3, 0.3), frameMat).translateY(9.2).translateX(wx).translateZ(22.7));
            g.add(new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.3, 0.3), frameMat).translateY(2.8).translateX(wx).translateZ(22.7));
        }
        
        // Sign
        var signCanvas = document.createElement('canvas');
        signCanvas.width = 512;
        signCanvas.height = 128;
        var ctx = signCanvas.getContext('2d');
        ctx.fillStyle = '#2a1a0a';
        ctx.fillRect(0, 0, 512, 128);
        ctx.fillStyle = '#d4af37';
        ctx.font = 'italic 40px Georgia';
        ctx.textAlign = 'center';
        ctx.fillText('The Grand Pavilion', 256, 75);
        var signTex = new THREE.CanvasTexture(signCanvas);
        g.add(new THREE.Mesh(
            new THREE.BoxGeometry(18, 4, 0.3),
            new THREE.MeshBasicMaterial({ map: signTex })
        ).translateY(14).translateZ(23));
        
        // Outdoor dining area
        for (var tx = -15; tx <= 15; tx += 7) {
            var table = new THREE.Group();
            table.add(new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.1, 16), new THREE.MeshLambertMaterial({ color: 0xffffff })).translateY(0.75));
            table.add(new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.7, 8), new THREE.MeshLambertMaterial({ color: 0x333333 })).translateY(0.35));
            // Umbrella
            table.add(new THREE.Mesh(new THREE.ConeGeometry(2.5, 1.5, 8), new THREE.MeshLambertMaterial({ color: 0x8b0000 })).translateY(3));
            table.add(new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 2.5, 8), new THREE.MeshLambertMaterial({ color: 0x5a3a2a })).translateY(1.8));
            table.position.set(tx, 0, 35);
            g.add(table);
        }
        
        // Valet area
        var valetCar = new THREE.Group();
        valetCar.add(new THREE.Mesh(new THREE.BoxGeometry(4, 1.2, 2), new THREE.MeshLambertMaterial({ color: 0x1a1a1a })).translateY(0.6));
        valetCar.add(new THREE.Mesh(new THREE.BoxGeometry(2.5, 1, 1.8), new THREE.MeshBasicMaterial({ color: 0x88aacc })).translateY(1.5));
        valetCar.position.set(25, 0, 30);
        g.add(valetCar);
        
        g.position.set(0, 0, 550);
        scene.add(g);
        
        missions.bigRestaurant.x = 0;
        missions.bigRestaurant.z = 525;
        buildingEntrances.push({ key: 'bigRestaurant', x: 0, z: 525 });
    }
    
    // ============ SECOND CATHEDRAL ============
    function createCathedral2() {
        var g = new THREE.Group();
        var stoneMat = new THREE.MeshLambertMaterial({ color: 0x9b8b7b });
        
        // Main nave
        g.add(new THREE.Mesh(new THREE.BoxGeometry(30, 25, 50), stoneMat).translateY(12.5));
        
        // Central dome
        g.add(new THREE.Mesh(new THREE.SphereGeometry(12, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2), stoneMat).translateY(25));
        
        // Bell tower
        g.add(new THREE.Mesh(new THREE.BoxGeometry(8, 40, 8), stoneMat).translateY(20).translateX(18));
        g.add(new THREE.Mesh(new THREE.ConeGeometry(5, 10, 4), stoneMat).translateY(45).translateX(18));
        
        // Rose window
        g.add(new THREE.Mesh(new THREE.CircleGeometry(4, 32), new THREE.MeshBasicMaterial({ color: 0x4488ff })).translateY(18).translateZ(25.1));
        
        // Entrance arch
        g.add(new THREE.Mesh(new THREE.TorusGeometry(4, 0.5, 8, 16, Math.PI), stoneMat).translateY(8).translateZ(25.1).rotateZ(Math.PI));
        g.add(new THREE.Mesh(new THREE.BoxGeometry(8, 8, 2), new THREE.MeshLambertMaterial({ color: 0x3a2a1a })).translateY(4).translateZ(25));
        
        // Stained glass windows
        var glassColors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff];
        for (var w = 0; w < 5; w++) {
            g.add(new THREE.Mesh(new THREE.BoxGeometry(2, 5, 0.2), new THREE.MeshBasicMaterial({ color: glassColors[w] })).translateY(15).translateZ(w * 8 - 15).translateX(15.1));
            g.add(new THREE.Mesh(new THREE.BoxGeometry(2, 5, 0.2), new THREE.MeshBasicMaterial({ color: glassColors[4-w] })).translateY(15).translateZ(w * 8 - 15).translateX(-15.1));
        }
        
        g.position.set(450, 0, 450);
        scene.add(g);
        
        missions.cathedral2.x = 450;
        missions.cathedral2.z = 480;
        buildingEntrances.push({ key: 'cathedral2', x: 450, z: 480 });
    }
    
    // ============ TECH HUB ============
    function createTechHub() {
        var g = new THREE.Group();
        var glassMat = new THREE.MeshStandardMaterial({ color: 0x88aacc, metalness: 0.8, roughness: 0.2, transparent: true, opacity: 0.7 });
        var frameMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
        
        // Modern glass building
        g.add(new THREE.Mesh(new THREE.BoxGeometry(40, 25, 35), glassMat).translateY(12.5));
        
        // Frame structure
        for (var fx = -18; fx <= 18; fx += 9) {
            g.add(new THREE.Mesh(new THREE.BoxGeometry(1, 25, 1), frameMat).translateY(12.5).translateX(fx).translateZ(17.5));
            g.add(new THREE.Mesh(new THREE.BoxGeometry(1, 25, 1), frameMat).translateY(12.5).translateX(fx).translateZ(-17.5));
        }
        
        // Horizontal beams
        for (var fy = 5; fy <= 25; fy += 5) {
            g.add(new THREE.Mesh(new THREE.BoxGeometry(40, 0.5, 0.5), frameMat).translateY(fy).translateZ(17.7));
        }
        
        // Roof with solar panels
        g.add(new THREE.Mesh(new THREE.BoxGeometry(38, 0.5, 33), new THREE.MeshLambertMaterial({ color: 0x1a1a3a })).translateY(25.5));
        
        // LED sign
        var signCanvas = document.createElement('canvas');
        signCanvas.width = 256;
        signCanvas.height = 64;
        var ctx = signCanvas.getContext('2d');
        ctx.fillStyle = '#0a0a2a';
        ctx.fillRect(0, 0, 256, 64);
        ctx.fillStyle = '#00ffff';
        ctx.font = 'bold 30px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('INNOVATION HUB', 128, 42);
        var signTex = new THREE.CanvasTexture(signCanvas);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(15, 4, 0.3), new THREE.MeshBasicMaterial({ map: signTex })).translateY(22).translateZ(17.7));
        
        // Holographic effect lights
        g.add(new THREE.PointLight(0x00ffff, 0.8, 30).translateY(15).translateZ(25));
        g.add(new THREE.PointLight(0xff00ff, 0.5, 20).translateY(10).translateZ(20));
        
        g.position.set(-450, 0, -450);
        scene.add(g);
        
        missions.techHub.x = -450;
        missions.techHub.z = -430;
        buildingEntrances.push({ key: 'techHub', x: -450, z: -430 });
    }
    
    function createLEDSigns() {
        var signs = [
            { x: 80, z: -80, text: 'WELCOME TO\nMETROPOLIS', color: '#00ffff' },
            { x: -80, z: -80, text: 'LEARN\nENGLISH', color: '#ff00ff' },
            { x: 80, z: 80, text: 'C1 LEVEL\nMASTERY', color: '#ffff00' },
            { x: -80, z: 80, text: 'EXPLORE\nDISCOVER', color: '#00ff00' },
            { x: 0, z: -250, text: 'BUSINESS\nDISTRICT ‚Üë', color: '#4488ff' },
            { x: 0, z: 250, text: 'SHOPPING\nCENTER ‚Üì', color: '#ff8844' },
            { x: 400, z: 0, text: 'STADIUM\n‚Üí', color: '#00ff00' },
            { x: -400, z: -100, text: '‚Üê NIGHTLIFE\nZONE', color: '#ff0066' },
            { x: 0, z: 400, text: 'FINE DINING\n‚Üì', color: '#d4af37' },
            { x: 0, z: -380, text: 'SKY TOWER\n‚Üë 120m', color: '#ffcc00' }
        ];
        
        signs.forEach(function(s) {
            var g = new THREE.Group();
            g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 10), new THREE.MeshLambertMaterial({ color: 0x444444 })).translateY(5));
            g.add(new THREE.Mesh(new THREE.BoxGeometry(12, 6, 0.5), new THREE.MeshLambertMaterial({ color: 0x222222 })).translateY(13));
            
            var canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, 256, 128);
            ctx.fillStyle = s.color;
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'center';
            s.text.split('\n').forEach(function(line, i) { ctx.fillText(line, 128, 45 + i * 35); });
            
            g.add(new THREE.Mesh(new THREE.BoxGeometry(11, 5.5, 0.1), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas) })).translateY(13).translateZ(0.3));
            
            var glow = new THREE.PointLight(parseInt(s.color.replace('#', '0x')), 0.6, 15);
            glow.position.set(0, 13, 2);
            g.add(glow);
            
            g.position.set(s.x, 0, s.z);
            scene.add(g);
        });
    }
    
    function createNPCs() {
        var outdoorKeys = Object.keys(missions).filter(function(k) { return missions[k].type === 'outdoor'; });
        var positions = [{ x: 45, z: -120 }, { x: 120, z: 120 }, { x: -120, z: 120 }, { x: 200, z: -180 }, { x: -200, z: -180 }, { x: 280, z: 100 }];
        
        outdoorKeys.forEach(function(key, i) {
            if (i < positions.length) {
                var m = missions[key];
                var person = createPerson(0x2c3e50, 0xffd5b4, 0x4a3728);
                person.position.set(positions[i].x, 0, positions[i].z);
                
                var canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                var ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.beginPath();
                ctx.arc(32, 32, 26, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(m.icon, 32, 32);
                var sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                sprite.position.y = 2.3;
                sprite.scale.set(1.1, 1.1, 1);
                person.add(sprite);
                
                scene.add(person);
                m.x = positions[i].x;
                m.z = positions[i].z;
                npcs.push({ mesh: person, x: positions[i].x, z: positions[i].z, missionKey: key, name: m.npcName, icon: m.icon });
            }
        });
        
        var parkKeys = Object.keys(missions).filter(function(k) { return missions[k].type === 'park'; });
        var parkPositions = [{ x: -45, z: -45 }, { x: 45, z: -45 }, { x: -45, z: 45 }, { x: 45, z: 45 }, { x: -145, z: 45 }, { x: 145, z: 45 }];
        
        parkKeys.forEach(function(key, i) {
            if (i < parkPositions.length) {
                var m = missions[key];
                var person = createPerson([0x3498db, 0xe74c3c, 0x2ecc71, 0x9b59b6, 0xf39c12, 0x1abc9c][i], 0xffd5b4, [0x4a3728, 0x2c2c2c, 0x8b4513, 0x333333, 0x4a3728, 0x2c2c2c][i]);
                person.position.set(parkPositions[i].x, 0, parkPositions[i].z);
                
                var canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                var ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(34,139,34,0.9)';
                ctx.beginPath();
                ctx.arc(32, 32, 26, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(m.icon, 32, 32);
                var sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                sprite.position.y = 2.3;
                sprite.scale.set(1.1, 1.1, 1);
                person.add(sprite);
                
                scene.add(person);
                m.x = parkPositions[i].x;
                m.z = parkPositions[i].z;
                parkNPCs.push({ mesh: person, x: parkPositions[i].x, z: parkPositions[i].z, missionKey: key, name: m.npcName, icon: m.icon });
            }
        });
    }
    
    function createPedestrians() {
        var roads = [-600, -500, -400, -300, -200, -100, 0, 100, 200, 300, 400, 500, 600];
        
        // Create 150 pedestrians with diverse appearances
        for (var i = 0; i < 150; i++) {
            var ped = createPerson(); // Random appearance
            var roadIdx = Math.floor(Math.random() * roads.length);
            var isHorizontal = Math.random() > 0.5;
            
            ped.userData = { speed: 0.015 + Math.random() * 0.025, direction: Math.random() > 0.5 ? 1 : -1, isHorizontal: isHorizontal, roadPos: roads[roadIdx], offset: Math.random() > 0.5 ? 13 : -13 };
            
            if (isHorizontal) {
                ped.position.set((Math.random() - 0.5) * 1400, 0, ped.userData.roadPos + ped.userData.offset);
                ped.rotation.y = ped.userData.direction > 0 ? 0 : Math.PI;
            } else {
                ped.position.set(ped.userData.roadPos + ped.userData.offset, 0, (Math.random() - 0.5) * 1400);
                ped.rotation.y = ped.userData.direction > 0 ? Math.PI / 2 : -Math.PI / 2;
            }
            
            scene.add(ped);
            pedestrians.push(ped);
        }
    }
    
    function createCars() {
        var carColors = [0xff0000, 0x0000ff, 0xffff00, 0x00ff00, 0xff8800, 0x00ffff, 0xffffff, 0x333333, 0x8b0000, 0x000080];
        var roads = [-600, -500, -400, -300, -200, -100, 0, 100, 200, 300, 400, 500, 600];
        
        // Create 70 cars
        for (var i = 0; i < 70; i++) {
            var car = new THREE.Group();
            var color = carColors[Math.floor(Math.random() * carColors.length)];
            car.add(new THREE.Mesh(new THREE.BoxGeometry(4.5, 1.2, 2.2), new THREE.MeshLambertMaterial({ color: color })).translateY(0.85));
            car.add(new THREE.Mesh(new THREE.BoxGeometry(2.2, 1, 2), new THREE.MeshLambertMaterial({ color: color })).translateY(1.8));
            // Headlights
            car.add(new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0xffffcc })).translateY(0.7).translateX(2).translateZ(0.8));
            car.add(new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0xffffcc })).translateY(0.7).translateX(2).translateZ(-0.8));
            // Taillights
            car.add(new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshBasicMaterial({ color: 0xff0000 })).translateY(0.7).translateX(-2.1).translateZ(0.8));
            car.add(new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshBasicMaterial({ color: 0xff0000 })).translateY(0.7).translateX(-2.1).translateZ(-0.8));
            
            var roadIdx = Math.floor(Math.random() * roads.length);
            var isHorizontal = Math.random() > 0.5;
            
            car.userData = { speed: 0.18 + Math.random() * 0.22, direction: Math.random() > 0.5 ? 1 : -1, isHorizontal: isHorizontal, roadPos: roads[roadIdx] };
            
            if (isHorizontal) {
                car.position.set((Math.random() - 0.5) * 1400, 0.4, car.userData.roadPos + (car.userData.direction > 0 ? -3.5 : 3.5));
                car.rotation.y = car.userData.direction > 0 ? 0 : Math.PI;
            } else {
                car.position.set(car.userData.roadPos + (car.userData.direction > 0 ? 3.5 : -3.5), 0.4, (Math.random() - 0.5) * 1400);
                car.rotation.y = car.userData.direction > 0 ? Math.PI / 2 : -Math.PI / 2;
            }
            
            scene.add(car);
            cars.push(car);
        }
    }
    
    function createBuses() {
        var busRoutes = [
            { road: 0, isHorizontal: true, dir: 1 },
            { road: 0, isHorizontal: true, dir: -1 },
            { road: 0, isHorizontal: false, dir: 1 },
            { road: 0, isHorizontal: false, dir: -1 },
            { road: 300, isHorizontal: true, dir: 1 },
            { road: -300, isHorizontal: true, dir: -1 },
            { road: 300, isHorizontal: false, dir: 1 },
            { road: -300, isHorizontal: false, dir: -1 },
            { road: 500, isHorizontal: true, dir: 1 },
            { road: -500, isHorizontal: false, dir: -1 }
        ];
        
        busRoutes.forEach(function(route, i) {
            var bus = new THREE.Group();
            bus.add(new THREE.Mesh(new THREE.BoxGeometry(10, 3, 3), new THREE.MeshLambertMaterial({ color: 0x00aa00 })).translateY(1.8));
            bus.add(new THREE.Mesh(new THREE.BoxGeometry(8, 2, 2.8), new THREE.MeshBasicMaterial({ color: 0x88ccff })).translateY(3.2));
            
            var signCanvas = document.createElement('canvas');
            signCanvas.width = 64;
            signCanvas.height = 32;
            var ctx = signCanvas.getContext('2d');
            ctx.fillStyle = '#ff0';
            ctx.fillRect(0, 0, 64, 32);
            ctx.fillStyle = '#000';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BUS ' + (i + 1), 32, 22);
            bus.add(new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 0.1), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(signCanvas) })).translateY(4).translateZ(1.51).translateX(3.5));
            
            bus.userData = { speed: 0.12, direction: route.dir, isHorizontal: route.isHorizontal, roadPos: route.road, isBus: true };
            
            if (route.isHorizontal) {
                bus.position.set((Math.random() - 0.5) * 600, 0.5, route.road + (route.dir > 0 ? -5 : 5));
                bus.rotation.y = route.dir > 0 ? 0 : Math.PI;
            } else {
                bus.position.set(route.road + (route.dir > 0 ? 5 : -5), 0.5, (Math.random() - 0.5) * 600);
                bus.rotation.y = route.dir > 0 ? Math.PI / 2 : -Math.PI / 2;
            }
            
            scene.add(bus);
            buses.push(bus);
        });
    }
    
    // ============ POLICE CARS ============
    function createPoliceCars() {
        var roads = [-400, -200, 0, 200, 400];
        
        for (var i = 0; i < 8; i++) {
            var car = new THREE.Group();
            
            // Body - white with blue stripe
            car.add(new THREE.Mesh(new THREE.BoxGeometry(4.5, 1.2, 2.2), new THREE.MeshLambertMaterial({ color: 0xffffff })).translateY(0.85));
            car.add(new THREE.Mesh(new THREE.BoxGeometry(2.2, 1, 2), new THREE.MeshLambertMaterial({ color: 0xffffff })).translateY(1.8));
            
            // Blue stripe
            car.add(new THREE.Mesh(new THREE.BoxGeometry(4.6, 0.3, 2.25), new THREE.MeshLambertMaterial({ color: 0x0044aa })).translateY(1.1));
            
            // Light bar
            var lightBar = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.25, 0.8), new THREE.MeshLambertMaterial({ color: 0x333333 }));
            lightBar.position.set(0, 2.45, 0);
            car.add(lightBar);
            
            // Red light
            var redLightMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.3), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            redLightMesh.position.set(-0.4, 2.55, 0);
            car.add(redLightMesh);
            var redLight = new THREE.PointLight(0xff0000, 2, 15);
            redLight.position.set(-0.4, 2.6, 0);
            car.add(redLight);
            
            // Blue light
            var blueLightMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.3), new THREE.MeshBasicMaterial({ color: 0x0066ff }));
            blueLightMesh.position.set(0.4, 2.55, 0);
            car.add(blueLightMesh);
            var blueLight = new THREE.PointLight(0x0066ff, 0.1, 15);
            blueLight.position.set(0.4, 2.6, 0);
            car.add(blueLight);
            
            // Headlights
            car.add(new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0xffffcc })).translateY(0.7).translateX(2).translateZ(0.8));
            car.add(new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0xffffcc })).translateY(0.7).translateX(2).translateZ(-0.8));
            
            var roadIdx = Math.floor(Math.random() * roads.length);
            var isHorizontal = Math.random() > 0.5;
            
            car.userData = { 
                speed: 0.25 + Math.random() * 0.15, 
                direction: Math.random() > 0.5 ? 1 : -1, 
                isHorizontal: isHorizontal, 
                roadPos: roads[roadIdx],
                redLight: redLight,
                blueLight: blueLight
            };
            
            if (isHorizontal) {
                car.position.set((Math.random() - 0.5) * 1200, 0.4, car.userData.roadPos + (car.userData.direction > 0 ? -3.5 : 3.5));
                car.rotation.y = car.userData.direction > 0 ? 0 : Math.PI;
            } else {
                car.position.set(car.userData.roadPos + (car.userData.direction > 0 ? 3.5 : -3.5), 0.4, (Math.random() - 0.5) * 1200);
                car.rotation.y = car.userData.direction > 0 ? Math.PI / 2 : -Math.PI / 2;
            }
            
            scene.add(car);
            policeCars.push(car);
        }
    }
    
    // ============ AIRPLANES ============
    function createAirplanes() {
        for (var i = 0; i < 3; i++) {
            var plane = new THREE.Group();
            
            // Fuselage
            var fuselage = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2, 25, 16),
                new THREE.MeshLambertMaterial({ color: 0xeeeeee })
            );
            fuselage.rotation.z = Math.PI / 2;
            plane.add(fuselage);
            
            // Nose cone
            var nose = new THREE.Mesh(
                new THREE.ConeGeometry(2, 5, 16),
                new THREE.MeshLambertMaterial({ color: 0xcccccc })
            );
            nose.rotation.z = -Math.PI / 2;
            nose.position.x = 15;
            plane.add(nose);
            
            // Tail
            var tail = new THREE.Mesh(
                new THREE.ConeGeometry(2, 4, 16),
                new THREE.MeshLambertMaterial({ color: 0xeeeeee })
            );
            tail.rotation.z = Math.PI / 2;
            tail.position.x = -14;
            plane.add(tail);
            
            // Wings
            var wingMat = new THREE.MeshLambertMaterial({ color: 0xdddddd });
            var leftWing = new THREE.Mesh(new THREE.BoxGeometry(12, 0.5, 35), wingMat);
            leftWing.position.set(0, 0, 0);
            plane.add(leftWing);
            
            // Tail fin (vertical)
            var tailFin = new THREE.Mesh(new THREE.BoxGeometry(5, 8, 0.5), wingMat);
            tailFin.position.set(-10, 4, 0);
            plane.add(tailFin);
            
            // Tail wings (horizontal)
            var tailWings = new THREE.Mesh(new THREE.BoxGeometry(3, 0.3, 12), wingMat);
            tailWings.position.set(-11, 0, 0);
            plane.add(tailWings);
            
            // Engines
            var engineMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
            var leftEngine = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.5, 5, 12), engineMat);
            leftEngine.rotation.z = Math.PI / 2;
            leftEngine.position.set(2, -1.5, 10);
            plane.add(leftEngine);
            
            var rightEngine = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.5, 5, 12), engineMat);
            rightEngine.rotation.z = Math.PI / 2;
            rightEngine.position.set(2, -1.5, -10);
            plane.add(rightEngine);
            
            // Windows
            var windowMat = new THREE.MeshBasicMaterial({ color: 0x88aacc });
            for (var w = -8; w <= 8; w += 2) {
                var window = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 0.1), windowMat);
                window.position.set(w, 1, 2.05);
                plane.add(window);
                var window2 = window.clone();
                window2.position.z = -2.05;
                plane.add(window2);
            }
            
            // Cockpit windows
            var cockpit = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 3.5), new THREE.MeshBasicMaterial({ color: 0x334455 }));
            cockpit.position.set(11, 0.8, 0);
            plane.add(cockpit);
            
            // Navigation light
            var navLight = new THREE.PointLight(0xff0000, 1, 30);
            navLight.position.set(-12, 0, 0);
            plane.add(navLight);
            
            // Airline colors - red stripe
            var stripe = new THREE.Mesh(new THREE.BoxGeometry(20, 1, 4.1), new THREE.MeshLambertMaterial({ color: 0xcc0000 }));
            stripe.position.set(0, 0, 0);
            plane.add(stripe);
            
            // Position high in sky
            plane.position.set(
                (Math.random() - 0.5) * 2000,
                80 + Math.random() * 50,
                (Math.random() - 0.5) * 2000
            );
            
            // Random direction
            var angle = Math.random() * Math.PI * 2;
            plane.userData = {
                speedX: Math.sin(angle) * (1.5 + Math.random()),
                speedZ: Math.cos(angle) * (1.5 + Math.random()),
                navLight: navLight
            };
            plane.rotation.y = Math.atan2(plane.userData.speedX, plane.userData.speedZ);
            
            scene.add(plane);
            airplanes.push(plane);
        }
    }
    
    // ============ SKY TOWER WITH ELEVATOR RESTAURANT ============
    function createSkyTower() {
        skyTower = new THREE.Group();
        
        var towerHeight = 120;
        var glassMat = new THREE.MeshStandardMaterial({ color: 0x4488aa, metalness: 0.9, roughness: 0.1, transparent: true, opacity: 0.7 });
        var frameMat = new THREE.MeshLambertMaterial({ color: 0x333344 });
        var concreteMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
        
        // Main tower shaft
        skyTower.add(new THREE.Mesh(new THREE.BoxGeometry(20, towerHeight, 20), glassMat).translateY(towerHeight / 2));
        
        // Frame structure
        for (var fx = -10; fx <= 10; fx += 10) {
            for (var fz = -10; fz <= 10; fz += 10) {
                skyTower.add(new THREE.Mesh(new THREE.BoxGeometry(1, towerHeight, 1), frameMat).translateY(towerHeight / 2).translateX(fx).translateZ(fz));
            }
        }
        
        // Horizontal frames every 15 units
        for (var fy = 15; fy < towerHeight; fy += 15) {
            skyTower.add(new THREE.Mesh(new THREE.BoxGeometry(22, 0.8, 22), frameMat).translateY(fy));
        }
        
        // Restaurant at top - rotating observation deck
        var restaurantFloor = new THREE.Mesh(new THREE.CylinderGeometry(18, 18, 2, 32), concreteMat);
        restaurantFloor.position.y = towerHeight;
        skyTower.add(restaurantFloor);
        
        // Glass walls for panoramic view
        var glassWall = new THREE.Mesh(
            new THREE.CylinderGeometry(17.5, 17.5, 8, 32, 1, true),
            new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
        );
        glassWall.position.y = towerHeight + 5;
        skyTower.add(glassWall);
        
        // Restaurant roof
        var roof = new THREE.Mesh(new THREE.CylinderGeometry(19, 18, 1.5, 32), concreteMat);
        roof.position.y = towerHeight + 9.5;
        skyTower.add(roof);
        
        // Spire on top
        var spire = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 1.5, 25, 8), new THREE.MeshLambertMaterial({ color: 0xaaaaaa }));
        spire.position.y = towerHeight + 22;
        skyTower.add(spire);
        
        // Antenna light
        var antennaLight = new THREE.PointLight(0xff0000, 1, 50);
        antennaLight.position.y = towerHeight + 35;
        skyTower.add(antennaLight);
        
        // Blinking beacon
        var beacon = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        beacon.position.y = towerHeight + 34;
        skyTower.add(beacon);
        
        // Elevator shaft (visible from outside)
        var elevatorShaft = new THREE.Mesh(
            new THREE.BoxGeometry(4, towerHeight, 4),
            new THREE.MeshStandardMaterial({ color: 0x333333, transparent: true, opacity: 0.5 })
        );
        elevatorShaft.position.set(0, towerHeight / 2, 12);
        skyTower.add(elevatorShaft);
        
        // Elevator car (moves up and down)
        var elevatorCar = new THREE.Mesh(
            new THREE.BoxGeometry(3.5, 4, 3.5),
            new THREE.MeshLambertMaterial({ color: 0xccaa00 })
        );
        elevatorCar.position.set(0, 2, 12);
        elevatorCar.name = 'elevatorCar';
        skyTower.add(elevatorCar);
        
        // Ground floor lobby
        var lobby = new THREE.Mesh(new THREE.BoxGeometry(30, 8, 30), new THREE.MeshLambertMaterial({ color: 0x444455 }));
        lobby.position.y = 4;
        skyTower.add(lobby);
        
        // Entrance doors
        var doorMat = new THREE.MeshBasicMaterial({ color: 0x88aacc });
        skyTower.add(new THREE.Mesh(new THREE.BoxGeometry(4, 5, 0.3), doorMat).translateY(2.5).translateZ(15.2));
        
        // Sign
        var signCanvas = document.createElement('canvas');
        signCanvas.width = 256;
        signCanvas.height = 64;
        var ctx = signCanvas.getContext('2d');
        ctx.fillStyle = '#001133';
        ctx.fillRect(0, 0, 256, 64);
        ctx.fillStyle = '#ffcc00';
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('SKY TOWER', 128, 42);
        var signTex = new THREE.CanvasTexture(signCanvas);
        skyTower.add(new THREE.Mesh(new THREE.BoxGeometry(12, 3, 0.3), new THREE.MeshBasicMaterial({ map: signTex })).translateY(10).translateZ(15.2));
        
        // Interior lights
        for (var fl = 20; fl <= towerHeight - 10; fl += 20) {
            var floorLight = new THREE.PointLight(0xffffcc, 0.3, 25);
            floorLight.position.set(0, fl, 0);
            skyTower.add(floorLight);
        }
        
        // Restaurant interior light
        var restaurantLight = new THREE.PointLight(0xffeecc, 1, 40);
        restaurantLight.position.set(0, towerHeight + 4, 0);
        skyTower.add(restaurantLight);
        
        skyTower.position.set(0, 0, -500);
        scene.add(skyTower);
        
        // Add entrance to building list
        skyTowerEntrance = { key: 'skyTower', x: 0, z: -485 };
        buildingEntrances.push(skyTowerEntrance);
    }
    
    // ============ SKY TOWER INTERIOR ============
    function createSkyTowerInterior() {
        interiorScene = new THREE.Scene();
        interiorScene.background = new THREE.Color(0x0a0a15);
        
        interiorCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        
        // Ambient light
        interiorScene.add(new THREE.AmbientLight(0xffffff, 0.3));
        
        // Restaurant floor
        var floorMat = new THREE.MeshStandardMaterial({ color: 0x2a2a3a, metalness: 0.3, roughness: 0.7 });
        interiorScene.add(new THREE.Mesh(new THREE.CylinderGeometry(16, 16, 0.3, 32), floorMat).translateY(0.15));
        
        // Ceiling
        interiorScene.add(new THREE.Mesh(new THREE.CylinderGeometry(17, 17, 0.3, 32), new THREE.MeshLambertMaterial({ color: 0x333344 })).translateY(7));
        
        // Panoramic glass walls - you can see the city!
        var glassMat = new THREE.MeshStandardMaterial({ 
            color: 0x88ccff, 
            transparent: true, 
            opacity: 0.2, 
            side: THREE.DoubleSide 
        });
        var glassWall = new THREE.Mesh(new THREE.CylinderGeometry(15.5, 15.5, 6.5, 32, 1, true), glassMat);
        glassWall.position.y = 3.5;
        interiorScene.add(glassWall);
        
        // Central column with elevator
        var columnMat = new THREE.MeshLambertMaterial({ color: 0x444455 });
        interiorScene.add(new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 7, 16), columnMat).translateY(3.5));
        
        // Dining tables around the edge
        for (var angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
            var tableGroup = new THREE.Group();
            
            // Table
            var table = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.05, 16), new THREE.MeshLambertMaterial({ color: 0xffffff }));
            table.position.y = 0.75;
            tableGroup.add(table);
            
            // Table leg
            tableGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.7, 8), new THREE.MeshLambertMaterial({ color: 0x333333 })).translateY(0.35));
            
            // Candle
            var candle = new THREE.PointLight(0xffaa44, 0.4, 3);
            candle.position.y = 0.9;
            tableGroup.add(candle);
            
            // Chairs
            for (var c = 0; c < 2; c++) {
                var chair = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.5), new THREE.MeshLambertMaterial({ color: 0x8b0000 }));
                chair.position.set(Math.cos(c * Math.PI) * 1.2, 0.3, Math.sin(c * Math.PI) * 1.2);
                tableGroup.add(chair);
            }
            
            // Diners at some tables
            if (Math.random() > 0.4) {
                var diner = createPerson();
                diner.position.set(Math.cos(0) * 1.1, 0, Math.sin(0) * 1.1);
                diner.scale.set(0.8, 0.8, 0.8);
                tableGroup.add(diner);
            }
            
            tableGroup.position.set(Math.cos(angle) * 11, 0, Math.sin(angle) * 11);
            tableGroup.rotation.y = -angle + Math.PI / 2;
            interiorScene.add(tableGroup);
        }
        
        // Bar area in center
        var barMat = new THREE.MeshLambertMaterial({ color: 0x3a2a2a });
        var bar = new THREE.Mesh(new THREE.TorusGeometry(3, 0.6, 8, 16, Math.PI), barMat);
        bar.rotation.x = Math.PI / 2;
        bar.position.set(0, 1.1, -4);
        interiorScene.add(bar);
        
        // Bartender
        var bartender = createPerson(0x1a1a1a);
        bartender.position.set(0, 0, -5);
        interiorScene.add(bartender);
        
        // Bottles behind bar
        var bottleColors = [0x00aa00, 0xaa0000, 0x0000aa, 0xaaaa00, 0xaa00aa];
        for (var b = -2; b <= 2; b++) {
            var bottle = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.4, 8), new THREE.MeshLambertMaterial({ color: bottleColors[b + 2] }));
            bottle.position.set(b * 0.4, 1.5, -5.5);
            interiorScene.add(bottle);
        }
        
        // Chandelier
        var chandelier = new THREE.Group();
        chandelier.add(new THREE.Mesh(new THREE.TorusGeometry(2, 0.1, 8, 32), new THREE.MeshLambertMaterial({ color: 0xccaa00 })));
        for (var cl = 0; cl < 8; cl++) {
            var crystalLight = new THREE.PointLight(0xffffcc, 0.3, 10);
            crystalLight.position.set(Math.cos(cl * Math.PI / 4) * 2, -0.3, Math.sin(cl * Math.PI / 4) * 2);
            chandelier.add(crystalLight);
            var crystal = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.4, 6), new THREE.MeshBasicMaterial({ color: 0xffffee }));
            crystal.position.copy(crystalLight.position);
            crystal.position.y -= 0.2;
            chandelier.add(crystal);
        }
        chandelier.position.y = 6;
        interiorScene.add(chandelier);
        
        // City view simulation - miniature buildings visible through glass
        for (var cv = 0; cv < 30; cv++) {
            var viewBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(2 + Math.random() * 3, 5 + Math.random() * 15, 2 + Math.random() * 3),
                new THREE.MeshBasicMaterial({ color: 0x222233 })
            );
            var dist = 30 + Math.random() * 40;
            var ang = Math.random() * Math.PI * 2;
            viewBuilding.position.set(Math.cos(ang) * dist, -50 + viewBuilding.geometry.parameters.height / 2, Math.sin(ang) * dist);
            // Window lights
            var windowGlow = new THREE.PointLight(0xffffaa, 0.1, 20);
            windowGlow.position.copy(viewBuilding.position);
            interiorScene.add(windowGlow);
            interiorScene.add(viewBuilding);
        }
        
        // Ground far below (visible through floor-to-ceiling windows)
        var distantGround = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshLambertMaterial({ color: 0x1a2a1a }));
        distantGround.rotation.x = -Math.PI / 2;
        distantGround.position.y = -115;
        interiorScene.add(distantGround);
        
        // Distant city lights
        for (var dl = 0; dl < 50; dl++) {
            var cityLight = new THREE.PointLight(0xffaa44, 0.2, 30);
            cityLight.position.set((Math.random() - 0.5) * 150, -110, (Math.random() - 0.5) * 150);
            interiorScene.add(cityLight);
        }
        
        interiorPlayerPos = { x: 0, z: 8 };
        interiorRot = { x: 0, y: 0 };
        interiorTargetRot = { x: 0, y: 0 };
    }
    
    function createTrees() {
        var roads = [-600, -500, -400, -300, -200, -100, 0, 100, 200, 300, 400, 500, 600];
        for (var i = 0; i < 300; i++) {
            var x = (Math.random() - 0.5) * 1600;
            var z = (Math.random() - 0.5) * 1600;
            var onRoad = false;
            roads.forEach(function(r) { if (Math.abs(x - r) < 12 || Math.abs(z - r) < 12) onRoad = true; });
            if (onRoad || (Math.abs(x) < 35 && Math.abs(z) < 35)) continue;
            // Avoid large buildings
            if (Math.abs(x - 550) < 80 && Math.abs(z) < 60) continue; // Stadium
            if (Math.abs(x + 550) < 60 && Math.abs(z + 150) < 50) continue; // Disco
            if (Math.abs(x) < 40 && Math.abs(z - 550) < 60) continue; // Restaurant
            if (Math.abs(x) < 25 && Math.abs(z + 500) < 25) continue; // Sky Tower
            createTree(x, z);
        }
    }
    
    function updatePedestrians() {
        animTime += 0.016;
        
        pedestrians.forEach(function(ped, idx) {
            var d = ped.userData;
            
            // Birds have special movement
            if (d.flapPhase !== undefined) {
                // Bird movement
                ped.position.x += d.speedX;
                ped.position.z += d.speedZ;
                
                // Circle movement
                d.speedX += (Math.random() - 0.5) * 0.01;
                d.speedZ += (Math.random() - 0.5) * 0.01;
                var speed = Math.sqrt(d.speedX * d.speedX + d.speedZ * d.speedZ);
                if (speed > 0.5) {
                    d.speedX *= 0.5 / speed;
                    d.speedZ *= 0.5 / speed;
                }
                
                // Stay in bounds
                if (ped.position.x > 800) { ped.position.x = 800; d.speedX = -Math.abs(d.speedX); }
                if (ped.position.x < -800) { ped.position.x = -800; d.speedX = Math.abs(d.speedX); }
                if (ped.position.z > 800) { ped.position.z = 800; d.speedZ = -Math.abs(d.speedZ); }
                if (ped.position.z < -800) { ped.position.z = -800; d.speedZ = Math.abs(d.speedZ); }
                
                // Wing flapping
                d.flapPhase += 0.3;
                var flapAngle = Math.sin(d.flapPhase) * 0.5;
                ped.children.forEach(function(child) {
                    if (child.name === 'leftWing') child.rotation.x = flapAngle;
                    if (child.name === 'rightWing') child.rotation.x = -flapAngle;
                });
                
                // Face direction of movement
                ped.rotation.y = Math.atan2(d.speedX, d.speedZ);
                
                // Slight vertical bobbing
                ped.position.y = 30 + Math.random() * 50 + Math.sin(animTime + idx) * 2;
                
                return;
            }
            
            // Regular pedestrian movement
            if (d.isHorizontal) {
                ped.position.x += d.speed * d.direction;
                if (ped.position.x > 750) ped.position.x = -750;
                if (ped.position.x < -750) ped.position.x = 750;
            } else {
                ped.position.z += d.speed * d.direction;
                if (ped.position.z > 750) ped.position.z = -750;
                if (ped.position.z < -750) ped.position.z = 750;
            }
            
            // Walking animation - arms and legs swing
            var walkPhase = animTime * d.speed * 150 + idx;
            var swing = Math.sin(walkPhase) * 0.4;
            
            // Animate body parts (children of the group)
            if (ped.children.length > 5) {
                // Left arm (index ~2-3)
                if (ped.children[2]) ped.children[2].rotation.x = swing;
                // Right arm (index ~4-5)  
                if (ped.children[4]) ped.children[4].rotation.x = -swing;
                // Left leg (index ~8-9)
                if (ped.children[8]) ped.children[8].rotation.x = -swing * 0.8;
                // Right leg (index ~10)
                if (ped.children[10]) ped.children[10].rotation.x = swing * 0.8;
            }
            
            // Slight body bob
            ped.position.y = Math.abs(Math.sin(walkPhase * 2)) * 0.03;
        });
        
        // Animate clouds
        scene.children.forEach(function(child) {
            if (child.userData && child.userData.speed && child.children && child.children.length > 3) {
                // This is likely a cloud
                child.position.x += child.userData.speed;
                if (child.position.x > 1200) child.position.x = -1200;
            }
        });
    }
    
    function updateTraffic() {
        // Regular cars
        cars.forEach(function(car) {
            var d = car.userData;
            if (d.isHorizontal) {
                car.position.x += d.speed * d.direction;
                if (car.position.x > 780) car.position.x = -780;
                if (car.position.x < -780) car.position.x = 780;
            } else {
                car.position.z += d.speed * d.direction;
                if (car.position.z > 780) car.position.z = -780;
                if (car.position.z < -780) car.position.z = 780;
            }
        });
        
        // Police cars with flashing lights
        policeCars.forEach(function(car) {
            var d = car.userData;
            if (d.isHorizontal) {
                car.position.x += d.speed * d.direction;
                if (car.position.x > 780) car.position.x = -780;
                if (car.position.x < -780) car.position.x = 780;
            } else {
                car.position.z += d.speed * d.direction;
                if (car.position.z > 780) car.position.z = -780;
                if (car.position.z < -780) car.position.z = 780;
            }
            
            // Flash lights
            var flash = Math.sin(animTime * 15) > 0;
            if (car.userData.redLight) car.userData.redLight.intensity = flash ? 2 : 0.1;
            if (car.userData.blueLight) car.userData.blueLight.intensity = flash ? 0.1 : 2;
        });
        
        // Buses
        buses.forEach(function(bus) {
            var d = bus.userData;
            if (d.isHorizontal) {
                bus.position.x += d.speed * d.direction;
                if (bus.position.x > 750) bus.position.x = -750;
                if (bus.position.x < -750) bus.position.x = 750;
            } else {
                bus.position.z += d.speed * d.direction;
                if (bus.position.z > 750) bus.position.z = -750;
                if (bus.position.z < -750) bus.position.z = 750;
            }
        });
        
        // Airplanes
        airplanes.forEach(function(plane) {
            var d = plane.userData;
            plane.position.x += d.speedX;
            plane.position.z += d.speedZ;
            
            // Reset position when out of bounds
            if (plane.position.x > 1200 || plane.position.x < -1200 || 
                plane.position.z > 1200 || plane.position.z < -1200) {
                // Respawn from random edge
                var side = Math.floor(Math.random() * 4);
                if (side === 0) { plane.position.x = -1200; plane.position.z = (Math.random() - 0.5) * 1500; d.speedX = 1.5 + Math.random(); d.speedZ = (Math.random() - 0.5) * 0.5; }
                else if (side === 1) { plane.position.x = 1200; plane.position.z = (Math.random() - 0.5) * 1500; d.speedX = -(1.5 + Math.random()); d.speedZ = (Math.random() - 0.5) * 0.5; }
                else if (side === 2) { plane.position.z = -1200; plane.position.x = (Math.random() - 0.5) * 1500; d.speedZ = 1.5 + Math.random(); d.speedX = (Math.random() - 0.5) * 0.5; }
                else { plane.position.z = 1200; plane.position.x = (Math.random() - 0.5) * 1500; d.speedZ = -(1.5 + Math.random()); d.speedX = (Math.random() - 0.5) * 0.5; }
                
                plane.position.y = 80 + Math.random() * 50;
                plane.rotation.y = Math.atan2(d.speedX, d.speedZ);
            }
            
            // Blinking lights
            if (plane.userData.navLight) {
                plane.userData.navLight.intensity = Math.sin(animTime * 3) > 0.8 ? 1 : 0.1;
            }
        });
        
        // Sky Tower elevator animation (exterior view)
        if (skyTower) {
            var elevatorCar = skyTower.getObjectByName('elevatorCar');
            if (elevatorCar) {
                // Continuous up/down animation
                var elevatorPhase = (animTime * 0.3) % 2;
                if (elevatorPhase < 1) {
                    elevatorCar.position.y = 2 + elevatorPhase * 113;
                } else {
                    elevatorCar.position.y = 115 - (elevatorPhase - 1) * 113;
                }
            }
            
            // Blinking beacon
            skyTower.children.forEach(function(child) {
                if (child.type === 'PointLight' && child.position.y > 130) {
                    child.intensity = Math.sin(animTime * 2) > 0 ? 1.5 : 0.2;
                }
            });
        }
        
        // Interior elevator animation (when player is riding)
        if (isInElevator && interiorScene) {
            elevatorY += (elevatorTargetY - elevatorY) * 0.01;
            
            // Move the view down as we go up
            var ground = interiorScene.getObjectByName('elevatorGround');
            if (ground) {
                ground.position.y = -elevatorY;
            }
            
            // Move all buildings down
            interiorScene.children.forEach(function(child) {
                if (child.geometry && child.geometry.type === 'BoxGeometry' && child.position.z > 20) {
                    child.position.y -= 0.4;
                }
            });
            
            // Update floor display
            var display = interiorScene.getObjectByName('floorDisplay');
            if (display && display.material.map) {
                var floor = Math.floor(elevatorY / 3) + 1;
                var ctx = display.material.map.image.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 64, 32);
                ctx.fillStyle = '#0f0';
                ctx.font = 'bold 24px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(floor.toString(), 32, 24);
                display.material.map.needsUpdate = true;
            }
        }
    }
    
    // ============ MAIN ANIMATION LOOP ============
    function animate() {
        requestAnimationFrame(animate);
        updatePedestrians();
        updateTraffic();
        
        if (isOnBus) {
            renderer.render(scene, camera);
        } else if (isInArcade && interiorScene && interiorCamera) {
            renderer.render(interiorScene, interiorCamera);
        } else if (isInside && interiorScene && interiorCamera) {
            updateInterior();
            renderer.render(interiorScene, interiorCamera);
        } else if (!isInside && scene && camera) {
            // Arrow Left/Right for turning
            if (keys['ArrowLeft']) targetRot.y += 0.045;
            if (keys['ArrowRight']) targetRot.y -= 0.045;
            
            // Apply rotation directly - no lag
            playerRot.x = targetRot.x;
            playerRot.y = targetRot.y;
            
            var isRunning = keys['ShiftLeft'] || keys['ShiftRight'];
            var maxSpeed = isRunning ? maxRunSpeed : maxWalkSpeed;
            var accel = isRunning ? acceleration * 1.5 : acceleration;
            
            // Calculate forward and right vectors based on camera Y rotation
            var forwardX = -Math.sin(playerRot.y);
            var forwardZ = -Math.cos(playerRot.y);
            var rightX = Math.cos(playerRot.y);
            var rightZ = -Math.sin(playerRot.y);
            
            // Get movement input
            var moveX = 0, moveZ = 0;
            
            // W = move forward (in direction camera faces)
            if (keys['KeyW'] || keys['ArrowUp']) {
                moveX += forwardX;
                moveZ += forwardZ;
            }
            // S = move backward
            if (keys['KeyS'] || keys['ArrowDown']) {
                moveX -= forwardX;
                moveZ -= forwardZ;
            }
            // D = strafe right
            if (keys['KeyD']) {
                moveX += rightX;
                moveZ += rightZ;
            }
            // A = strafe left
            if (keys['KeyA']) {
                moveX -= rightX;
                moveZ -= rightZ;
            }
            
            // Apply movement
            if (moveX !== 0 || moveZ !== 0) {
                // Normalize diagonal movement
                var len = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= len;
                moveZ /= len;
                
                playerVel.x += moveX * accel;
                playerVel.z += moveZ * accel;
                
                headBob.phase += isRunning ? 0.18 : 0.12;
                headBob.intensity = isRunning ? 0.06 : 0.03;
            } else {
                headBob.intensity *= 0.9;
            }
            
            playerVel.x *= groundFriction;
            playerVel.z *= groundFriction;
            
            var speed = Math.sqrt(playerVel.x * playerVel.x + playerVel.z * playerVel.z);
            if (speed > maxSpeed) {
                playerVel.x = (playerVel.x / speed) * maxSpeed;
                playerVel.z = (playerVel.z / speed) * maxSpeed;
            }
            
            playerPos.x = Math.max(-780, Math.min(780, playerPos.x + playerVel.x));
            playerPos.z = Math.max(-780, Math.min(780, playerPos.z + playerVel.z));
            
            var bobY = Math.sin(headBob.phase) * headBob.intensity;
            
            camera.position.set(playerPos.x, playerPos.y + bobY, playerPos.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = playerRot.y;
            camera.rotation.x = playerRot.x;
            
            var nearNPC = null, nearDist = 5;
            npcs.concat(parkNPCs).forEach(function(n) {
                var d = Math.sqrt((playerPos.x - n.x) ** 2 + (playerPos.z - n.z) ** 2);
                if (d < nearDist) { nearDist = d; nearNPC = n; }
            });
            
            var nearBldg = null, nearBldgDist = 10;
            buildingEntrances.concat(skyscraperEntrances).forEach(function(b) {
                var d = Math.sqrt((playerPos.x - b.x) ** 2 + (playerPos.z - b.z) ** 2);
                if (d < nearBldgDist) { nearBldgDist = d; nearBldg = b; }
            });
            
            var nearBus = null, nearBusDist = 8;
            buses.forEach(function(b) {
                var d = Math.sqrt((playerPos.x - b.position.x) ** 2 + (playerPos.z - b.position.z) ** 2);
                if (d < nearBusDist) { nearBusDist = d; nearBus = b; }
            });
            
            currentNPC = nearNPC;
            currentBuilding = nearBldg;
            currentBus = nearBus;
            
            if (nearNPC) showPrompt('npc', nearNPC);
            else if (nearBldg) showPrompt('building', { name: missions[nearBldg.key].buildingName });
            else if (nearBus) showPrompt('bus', { name: 'City Bus' });
            else hidePrompt();
            
            updateMinimap();
            updateWaypoint();
            
            renderer.render(scene, camera);
        }
    }
    
    // ============ INPUT HANDLERS ============
    document.addEventListener('keydown', function(e) {
        keys[e.code] = true;
        
        if (e.code === 'Space') {
            e.preventDefault();
            if (isInside && !isInArcade) {
                startDialogue(currentInteriorKey);
            } else if (currentNPC && !isInside) {
                startDialogue(currentNPC.missionKey);
            } else if (currentBuilding && !isInside) {
                enterBuilding();
            } else if (currentBus && !isInside && !isOnBus) {
                boardBus();
            }
        }
        
        if (e.code === 'KeyE' && isInside && !isInArcade) {
            showPaper();
        }
        
        if (e.code === 'Tab') {
            e.preventDefault();
            var panel = document.getElementById('mission-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            updateMissionList();
        }
        
        if (e.code === 'Escape' && pacmanRunning) {
            quitPacman();
        }
    });
    
    document.addEventListener('keyup', function(e) { keys[e.code] = false; });
    
    window.addEventListener('resize', function() {
        if (camera) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }
        if (interiorCamera) {
            interiorCamera.aspect = window.innerWidth / window.innerHeight;
            interiorCamera.updateProjectionMatrix();
        }
        if (renderer) renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ============ UI EVENT LISTENERS ============
    document.getElementById('start-btn').onclick = startGame;
    document.getElementById('btn-talk').onclick = function() { startDialogue(currentInteriorKey); };
    document.getElementById('btn-paper').onclick = showPaper;
    document.getElementById('btn-exit').onclick = exitBuilding;
    document.getElementById('btn-exit-arcade').onclick = exitBuilding;
    document.getElementById('btn-bus-routes').onclick = showBusRoutes;
    document.getElementById('btn-exit-bus').onclick = exitBus;
    document.getElementById('btn-close-routes').onclick = closeBusRoutes;
    document.getElementById('dlg-close').onclick = closeDialogue;
    document.getElementById('dlg-listen').onclick = function(e) { e.stopPropagation(); if (currentMission && currentMission.dialogues[dialogueIndex]) speak(currentMission.dialogues[dialogueIndex].npc); };
    document.getElementById('paper-close').onclick = closePaper;
    
    // ============ PAC-MAN ============
    var pacmanRunning = false;
    var pacmanInterval = null;
    var pacScore = 0, pacHighScore = 0, pacLives = 3;
    var pacCanvas, pacCtx;
    var pacman, ghosts;
    var pacDirection = { x: 0, y: 0 }, pacNextDirection = { x: 0, y: 0 };
    var TILE = 24;
    var maze;
    
    var mazeTemplate = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
        [1,3,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,3,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
        [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
        [1,1,1,1,2,1,1,1,4,1,4,1,1,1,2,1,1,1,1],
        [4,4,4,1,2,1,4,4,4,4,4,4,4,1,2,1,4,4,4],
        [1,1,1,1,2,1,4,1,1,4,1,1,4,1,2,1,1,1,1],
        [4,4,4,4,2,4,4,1,4,4,4,1,4,4,2,4,4,4,4],
        [1,1,1,1,2,1,4,1,1,1,1,1,4,1,2,1,1,1,1],
        [4,4,4,1,2,1,4,4,4,4,4,4,4,1,2,1,4,4,4],
        [1,1,1,1,2,1,4,1,1,1,1,1,4,1,2,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
        [1,3,2,1,2,2,2,2,2,4,2,2,2,2,2,1,2,3,1],
        [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
        [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
        [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];
    
    function initPacman() {
        pacCanvas = document.getElementById('pacman-canvas');
        pacCtx = pacCanvas.getContext('2d');
        resetPacmanGame();
    }
    
    function resetPacmanGame() {
        pacScore = 0;
        pacLives = 3;
        maze = JSON.parse(JSON.stringify(mazeTemplate));
        pacman = { x: 9 * TILE + TILE / 2, y: 15 * TILE + TILE / 2, radius: 10, speed: 2, mouthAngle: 0.2, mouthDir: 1 };
        ghosts = [
            { x: 9 * TILE + TILE / 2, y: 9 * TILE + TILE / 2, color: '#ff0066', scared: false, scaredTimer: 0, dx: 1.5, dy: 0 },
            { x: 8 * TILE + TILE / 2, y: 9 * TILE + TILE / 2, color: '#00ffff', scared: false, scaredTimer: 0, dx: -1.5, dy: 0 },
            { x: 10 * TILE + TILE / 2, y: 9 * TILE + TILE / 2, color: '#ffaa00', scared: false, scaredTimer: 0, dx: 0, dy: 1.5 },
            { x: 9 * TILE + TILE / 2, y: 8 * TILE + TILE / 2, color: '#ff00ff', scared: false, scaredTimer: 0, dx: 0, dy: -1.5 }
        ];
        pacDirection = { x: 0, y: 0 };
        pacNextDirection = { x: 0, y: 0 };
        updatePacmanHUD();
    }
    
    function updatePacmanHUD() {
        document.getElementById('pac-score').textContent = pacScore;
        document.getElementById('pac-high').textContent = pacHighScore;
        document.getElementById('pac-lives').textContent = pacLives;
    }
    
    function drawPacmanGame() {
        pacCtx.fillStyle = '#0a0a0a';
        pacCtx.fillRect(0, 0, pacCanvas.width, pacCanvas.height);
        
        for (var row = 0; row < maze.length; row++) {
            for (var col = 0; col < maze[row].length; col++) {
                var cell = maze[row][col];
                var x = col * TILE, y = row * TILE;
                
                if (cell === 1) {
                    pacCtx.fillStyle = '#001a33';
                    pacCtx.fillRect(x, y, TILE, TILE);
                    pacCtx.strokeStyle = '#00ffff';
                    pacCtx.lineWidth = 2;
                    pacCtx.strokeRect(x + 1, y + 1, TILE - 2, TILE - 2);
                } else if (cell === 2) {
                    pacCtx.beginPath();
                    pacCtx.arc(x + TILE / 2, y + TILE / 2, 3, 0, Math.PI * 2);
                    pacCtx.fillStyle = '#ffff00';
                    pacCtx.shadowColor = '#ffff00';
                    pacCtx.shadowBlur = 5;
                    pacCtx.fill();
                    pacCtx.shadowBlur = 0;
                } else if (cell === 3) {
                    var pulse = Math.sin(Date.now() / 200) * 2 + 6;
                    pacCtx.beginPath();
                    pacCtx.arc(x + TILE / 2, y + TILE / 2, pulse, 0, Math.PI * 2);
                    pacCtx.fillStyle = '#ff00ff';
                    pacCtx.shadowColor = '#ff00ff';
                    pacCtx.shadowBlur = 15;
                    pacCtx.fill();
                    pacCtx.shadowBlur = 0;
                }
            }
        }
        
        ghosts.forEach(function(ghost) {
            pacCtx.beginPath();
            pacCtx.arc(ghost.x, ghost.y - 2, 10, Math.PI, 0);
            pacCtx.lineTo(ghost.x + 10, ghost.y + 8);
            for (var w = 0; w < 5; w++) pacCtx.lineTo(ghost.x + 10 - w * 5, ghost.y + 8 + (w % 2 === 0 ? 4 : 0));
            pacCtx.closePath();
            var ghostColor = ghost.scared ? '#0044ff' : ghost.color;
            pacCtx.fillStyle = ghostColor;
            pacCtx.shadowColor = ghostColor;
            pacCtx.shadowBlur = 15;
            pacCtx.fill();
            pacCtx.shadowBlur = 0;
            if (!ghost.scared) {
                pacCtx.fillStyle = '#fff';
                pacCtx.beginPath();
                pacCtx.arc(ghost.x - 4, ghost.y - 3, 4, 0, Math.PI * 2);
                pacCtx.arc(ghost.x + 4, ghost.y - 3, 4, 0, Math.PI * 2);
                pacCtx.fill();
                pacCtx.fillStyle = '#00f';
                pacCtx.beginPath();
                pacCtx.arc(ghost.x - 3, ghost.y - 2, 2, 0, Math.PI * 2);
                pacCtx.arc(ghost.x + 5, ghost.y - 2, 2, 0, Math.PI * 2);
                pacCtx.fill();
            }
        });
        
        pacCtx.beginPath();
        var startAngle = pacman.mouthAngle, endAngle = Math.PI * 2 - pacman.mouthAngle;
        var rotation = 0;
        if (pacDirection.x > 0) rotation = 0;
        else if (pacDirection.x < 0) rotation = Math.PI;
        else if (pacDirection.y > 0) rotation = Math.PI / 2;
        else if (pacDirection.y < 0) rotation = -Math.PI / 2;
        pacCtx.arc(pacman.x, pacman.y, pacman.radius, startAngle + rotation, endAngle + rotation);
        pacCtx.lineTo(pacman.x, pacman.y);
        pacCtx.closePath();
        pacCtx.fillStyle = '#ffff00';
        pacCtx.shadowColor = '#ffff00';
        pacCtx.shadowBlur = 20;
        pacCtx.fill();
        pacCtx.shadowBlur = 0;
        
        pacman.mouthAngle += 0.05 * pacman.mouthDir;
        if (pacman.mouthAngle > 0.4 || pacman.mouthAngle < 0.05) pacman.mouthDir *= -1;
    }
    
    function canMove(x, y) {
        var col = Math.floor(x / TILE), row = Math.floor(y / TILE);
        if (row < 0 || row >= maze.length || col < 0 || col >= maze[0].length) return true;
        return maze[row][col] !== 1;
    }
    
    function updatePacman() {
        var nextX = pacman.x + pacNextDirection.x * pacman.speed;
        var nextY = pacman.y + pacNextDirection.y * pacman.speed;
        if (canMove(nextX - 8, nextY - 8) && canMove(nextX + 8, nextY - 8) && canMove(nextX - 8, nextY + 8) && canMove(nextX + 8, nextY + 8)) {
            pacDirection = { x: pacNextDirection.x, y: pacNextDirection.y };
        }
        nextX = pacman.x + pacDirection.x * pacman.speed;
        nextY = pacman.y + pacDirection.y * pacman.speed;
        if (canMove(nextX - 8, nextY - 8) && canMove(nextX + 8, nextY - 8) && canMove(nextX - 8, nextY + 8) && canMove(nextX + 8, nextY + 8)) {
            pacman.x = nextX;
            pacman.y = nextY;
        }
        if (pacman.x < 0) pacman.x = pacCanvas.width;
        if (pacman.x > pacCanvas.width) pacman.x = 0;
        
        var col = Math.floor(pacman.x / TILE), row = Math.floor(pacman.y / TILE);
        if (row >= 0 && row < maze.length && col >= 0 && col < maze[0].length) {
            if (maze[row][col] === 2) { maze[row][col] = 4; pacScore += 10; updatePacmanHUD(); }
            else if (maze[row][col] === 3) {
                maze[row][col] = 4;
                pacScore += 50;
                ghosts.forEach(function(g) { g.scared = true; g.scaredTimer = 300; });
                updatePacmanHUD();
            }
        }
        
        var dotsLeft = 0;
        maze.forEach(function(r) { r.forEach(function(c) { if (c === 2 || c === 3) dotsLeft++; }); });
        if (dotsLeft === 0) {
            document.getElementById('pacman-message').textContent = 'üéâ YOU WIN! üéâ';
            pacmanRunning = false;
            if (pacScore > pacHighScore) pacHighScore = pacScore;
            updatePacmanHUD();
        }
    }
    
    function updateGhosts() {
        ghosts.forEach(function(ghost) {
            if (ghost.scared) { ghost.scaredTimer--; if (ghost.scaredTimer <= 0) ghost.scared = false; }
            var speed = ghost.scared ? 1 : 1.8;
            var nextX = ghost.x + ghost.dx * (speed / 1.5);
            var nextY = ghost.y + ghost.dy * (speed / 1.5);
            if (!canMove(nextX, nextY)) {
                var dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]].filter(function(d) { return canMove(ghost.x + d[0] * TILE / 2, ghost.y + d[1] * TILE / 2); });
                if (dirs.length > 0) { var nd = dirs[Math.floor(Math.random() * dirs.length)]; ghost.dx = nd[0] * 1.5; ghost.dy = nd[1] * 1.5; }
            } else { ghost.x = nextX; ghost.y = nextY; }
            if (Math.random() < 0.02) {
                var dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]].filter(function(d) { return canMove(ghost.x + d[0] * TILE / 2, ghost.y + d[1] * TILE / 2); });
                if (dirs.length > 0) { var nd = dirs[Math.floor(Math.random() * dirs.length)]; ghost.dx = nd[0] * 1.5; ghost.dy = nd[1] * 1.5; }
            }
            if (ghost.x < 0) ghost.x = pacCanvas.width;
            if (ghost.x > pacCanvas.width) ghost.x = 0;
            
            var dist = Math.sqrt((ghost.x - pacman.x) ** 2 + (ghost.y - pacman.y) ** 2);
            if (dist < 15) {
                if (ghost.scared) {
                    pacScore += 200;
                    ghost.x = 9 * TILE + TILE / 2;
                    ghost.y = 9 * TILE + TILE / 2;
                    ghost.scared = false;
                    updatePacmanHUD();
                } else {
                    pacLives--;
                    updatePacmanHUD();
                    if (pacLives <= 0) {
                        document.getElementById('pacman-message').textContent = 'üíÄ GAME OVER üíÄ';
                        pacmanRunning = false;
                        if (pacScore > pacHighScore) pacHighScore = pacScore;
                        updatePacmanHUD();
                    } else {
                        pacman.x = 9 * TILE + TILE / 2;
                        pacman.y = 15 * TILE + TILE / 2;
                        pacDirection = { x: 0, y: 0 };
                    }
                }
            }
        });
    }
    
    function pacmanGameLoop() {
        if (!pacmanRunning) return;
        updatePacman();
        updateGhosts();
        drawPacmanGame();
    }
    
    function startPacman() {
        document.getElementById('pacman-overlay').classList.remove('hidden');
        initPacman();
        document.getElementById('pacman-message').textContent = '';
        pacmanRunning = true;
        if (pacmanInterval) clearInterval(pacmanInterval);
        pacmanInterval = setInterval(pacmanGameLoop, 1000 / 60);
    }
    
    function quitPacman() {
        pacmanRunning = false;
        if (pacmanInterval) clearInterval(pacmanInterval);
        document.getElementById('pacman-overlay').classList.add('hidden');
    }
    
    document.addEventListener('keydown', function(e) {
        if (!pacmanRunning) return;
        if (e.code === 'ArrowUp' || e.code === 'KeyW') { pacNextDirection = { x: 0, y: -1 }; e.preventDefault(); }
        else if (e.code === 'ArrowDown' || e.code === 'KeyS') { pacNextDirection = { x: 0, y: 1 }; e.preventDefault(); }
        else if (e.code === 'ArrowLeft' || e.code === 'KeyA') { pacNextDirection = { x: -1, y: 0 }; e.preventDefault(); }
        else if (e.code === 'ArrowRight' || e.code === 'KeyD') { pacNextDirection = { x: 1, y: 0 }; e.preventDefault(); }
    });
    
    document.getElementById('btn-play-pacman').onclick = startPacman;
    document.getElementById('pac-start').onclick = function() { resetPacmanGame(); document.getElementById('pacman-message').textContent = ''; pacmanRunning = true; };
    document.getElementById('pac-quit').onclick = quitPacman;
    
    // ============ INIT ============
    window.onload = function() { initVoices(); updateHUD(); };
})();
    </script>
</body>
</html>
